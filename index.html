<!DOCTYPE html>
<html lang="it" class="dark">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rotazioni Basket</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÄ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { gray: { 900: '#111827', 800: '#1f2937', 700: '#374151' } } }
        }
    </script>

    <style>
        /* INCLUSIONE DEL FONT DS-Digital - Assicurati che DS-DIGII.TTF sia presente */
        @font-face {
            font-family: 'DS-Digital';
            src: url('DS-DIGII.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior-y: contain; transition: background-color 0.3s, color 0.3s;
        }
        
        /* COURT STYLES */
        .court-area {
            background-color: #eebb88;
            background-image: repeating-linear-gradient(0deg, transparent 0px, transparent 58px, rgba(160, 82, 45, 0.15) 59px, rgba(160, 82, 45, 0.15) 60px), repeating-linear-gradient(0deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 30px, transparent 30px, transparent 60px);
            border: 6px solid #ffffff; 
            box-shadow: inset 0 0 60px rgba(0,0,0,0.15); 
            position: relative; 
            overflow-y: auto; 
            min-height: 400px;
        }
        .court-lines::before { content: ''; position: absolute; top: 50%; left: 0; right: 0;
            height: 4px; background: #ffffff; pointer-events: none; z-index: 1; }
        .court-lines::after { content: '';
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 120px; height: 120px; border: 4px solid #ffffff; border-radius: 50%;
            pointer-events: none; z-index: 1; }
        .dark .court-area { background-color: #cfa06b; border-color: #e2e8f0;
        }
        
        .bench-area {
            background-color: #f8fafc;
            background-image: linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%, #e2e8f0), linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%, #e2e8f0);
            background-size: 20px 20px; border: 2px dashed #94a3b8; min-height: 140px;
        }
        .dark .bench-area {
            background-color: #1e293b;
            background-image: linear-gradient(45deg, #334155 25%, transparent 25%, transparent 75%, #334155 75%, #334155), linear-gradient(45deg, #334155 25%, transparent 25%, transparent 75%, #334155 75%, #334155);
            border-color: #475569;
        }
        
        /* CARD STYLES */
        .player-card {
            touch-action: manipulation;
            cursor: pointer; background: rgba(255, 255, 255, 0.98); border-radius: 10px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.15s ease, box-shadow 0.15s; z-index: 10; position: relative; 
            min-height: 9rem; 
            height: auto;
            select-none: none; user-select: none;
        }
        .player-card.on-court { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.2); color: white; box-shadow: 0 8px 20px -4px rgba(0, 0, 0, 0.4);
        }
        .dark .player-card:not(.on-court) { background: rgba(30, 41, 59, 0.98); color: #f1f5f9;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .player-card:active { transform: scale(0.96);
        }
        /* STILE COLD STATUS */
        .player-card.cold-status {
            background-color: #3b82f640; /* Blue-500 light, cold background */
            border: 2px solid #3b82f6;
        }
        .dark .player-card.cold-status {
            background-color: #1e3a8a; /* Darker blue */
            border: 2px solid #60a5fa;
        }

        .selected-card { ring-width: 3px; ring-color: #fbbf24; transform: scale(1.02);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.5); border-color: #fbbf24 !important; z-index: 20;
        }
        .court-number { color: #fbbf24; font-size: 1.6rem; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* TIMER FONT DIGITALE E COLORE ROSSO FISSO */
        .timer-display { 
            font-family: 'DS-Digital', 'Courier New', monospace;
            font-weight: 700; 
            font-size: 3rem; 
            line-height: 1; 
            letter-spacing: -2px; 
            color: #ef4444;
        }

        .custom-scroll::-webkit-scrollbar { width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 20px;
        }
    </style>
</head>
<body class="p-2 sm:p-6 bg-gray-100 dark:bg-gray-900 select-none h-screen flex flex-col">

    <div class="max-w-7xl mx-auto w-full flex flex-col h-full safe-area-padding">
        
        <header class="flex justify-between items-center mb-3 py-2 flex-shrink-0 flex-wrap gap-4">
            <div class="flex flex-col sm:flex-row sm:items-center sm:gap-4 flex-1">
                <div><h1 class="text-2xl sm:text-3xl font-extrabold text-gray-800 dark:text-white tracking-tight">üèÄ Rotazioni <span class="text-blue-600">Pro</span></h1></div>

          
                <div class="mt-2 sm:mt-0 flex items-center">
                    <label for="opponent-name" class="text-sm font-medium text-gray-500 dark:text-gray-400 mr-2 flex-shrink-0">Avversaria:</label>
                    <input type="text" id="opponent-name" placeholder="Nome Squadra Avversaria" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-white font-medium text-sm py-1 px-2 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none w-full max-w-xs">
                </div>
     
            </div>
            
            <div class="flex items-center space-x-3 order-last">
                <button onclick="exportToCSV()" class="p-2 rounded-full bg-blue-600 dark:bg-blue-700 text-white shadow-sm hover:shadow-md transition active:scale-95 text-xs font-bold uppercase" title="Esporta Statistiche in CSV">
                    CSV
            
            </button>
                <button id="theme-toggle" onclick="toggleTheme()" class="p-2 rounded-full bg-white dark:bg-gray-800 text-gray-800 dark:text-yellow-400 shadow-sm hover:shadow-md transition">
                    <svg id="sun-icon" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                   
                <svg id="moon-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </button>
            </div>
        </header>
        
        <div id="setup-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 hidden">
          
            <div class="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-md border border-gray-200 dark:border-gray-700">
                <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Roster Squadra</h2>
                <textarea id="player-input" rows="8" class="w-full p-4 border border-gray-200 rounded-xl bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-lg font-medium focus:ring-2 focus:ring-blue-500 outline-none transition" placeholder="Esempio:
00. Leardini
23 James">00 Leardini
7 Tomassini
11 Denegri
12 Sankare
13 Marini
17 Ogden
18 Pollone
22 Robinson
27 Simioni
29 Camara</textarea>
                <p class="text-gray-500 text-sm mt-2">Inserisci: 
            "Numero. Nome" oppure "Numero Nome".</p>
                <button onclick="initializeGame()" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 rounded-xl shadow-lg transform active:scale-95 transition text-lg">Inizia Partita</button>
            </div>
        </div>

        <div id="game-container" class="flex-1 flex flex-col min-h-0 pb-4 hidden">
            
            <div class="bg-white dark:bg-gray-800 p-3 sm:p-4 rounded-2xl 
            shadow-sm mb-4 flex flex-wrap sm:flex-nowrap justify-between items-center gap-4 border border-gray-200 dark:border-gray-700 flex-shrink-0">
                <div class="flex-1 text-center sm:text-left order-1 sm:order-2 flex justify-center items-center gap-3">
                    <button onclick="adjustTime(30000)" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-white font-bold shadow-sm transition active:scale-95 flex items-center justify-center text-xs">+30"</button>
                    <div class="bg-gray-100 dark:bg-gray-900 px-6 py-2 rounded-xl 
                    border border-gray-200 dark:border-gray-700 inline-block min-w-[200px]">
                        <span id="timer-display" class="timer-display tabular-nums">10:00</span>
                    </div>
                    <button onclick="adjustTime(-30000)" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-white font-bold shadow-sm transition active:scale-95 flex items-center justify-center text-xs">-30"</button>
           
                </div>

                <div class="w-full sm:w-auto order-2 sm:order-3">
                    <select id="quarter-select" onchange="changeQuarter()" class="w-full sm:w-auto bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 text-gray-800 dark:text-white font-bold text-lg py-3 px-4 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer">
                        <option value="Q1">Q1</option>
          
                        <option value="Q2">Q2</option>
                        <option value="Q3">Q3</option>
                        <option value="Q4">Q4</option>
                        <option value="OT">OT</option>
          
                    </select>
                </div>
                
                <div class="flex gap-2 w-full sm:w-auto order-3 sm:order-1 justify-center">
                    <button id="start-pause-btn" onclick="toggleTimer()" class="flex-1 sm:flex-none bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 
                    transition w-28">Avvia</button>
                    <button onclick="showSetupOrGame(false);
                    clearInterval(timerInterval); stopWallClockTracker(); gameState.isRunning = false;" class="flex-1 sm:flex-none bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 transition w-28">Reset</button>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 flex-1 min-h-0">
                <div class="lg:col-span-3 flex flex-col min-h-0 order-2 lg:order-1">
   
                    <div class="bg-white dark:bg-gray-800 rounded-t-xl p-3 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center">
                        <h2 class="font-bold text-gray-500 dark:text-gray-400 uppercase text-sm tracking-wider">Panchina</h2>
                        <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-gray-500">Tocca</span>
            
                    </div>
                    <div id="bench-area" class="bench-area p-3 rounded-b-xl flex-1 overflow-y-auto custom-scroll grid grid-cols-2 lg:grid-cols-1 gap-3 content-start shadow-inner" ondrop="handleDrop(event)" ondragover="allowDrop(event)" onclick="handleAreaClick('bench')"></div>
                </div>
                
                <div class="lg:col-span-9 flex flex-col min-h-0 order-1 lg:order-2 space-y-4">
 
                    <div class="relative rounded-2xl overflow-hidden shadow-2xl border-[6px] border-white dark:border-gray-500 flex-1 flex flex-col">
                        <div class="absolute top-0 left-0 bg-black/50 text-white px-4 py-1 rounded-br-xl z-20 text-sm font-bold uppercase backdrop-blur-md shadow-sm">In Campo</div>
                        <div class="court-lines absolute inset-0 z-0"></div>
    
                        <div id="court-area" class="court-area relative z-10 p-4 sm:p-6 flex-1 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4 content-start items-start" ondrop="handleDrop(event)" ondragover="allowDrop(event)" onclick="handleAreaClick('court')"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col h-48 lg:h-64">
           
                        <div class="p-3 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center"><h2 class="font-bold text-gray-500 dark:text-gray-400 uppercase text-sm tracking-wider">Tabellino</h2></div>
                        <div id="total-stats-area" class="overflow-y-auto custom-scroll p-0 flex-1"></div>
                    </div>
                </div>
         
            </div>
        </div>
        
        <div id="message-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60] hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-2xl max-w-xs mx-4 text-center">
                <p id="modal-text" class="text-lg font-medium text-gray-800 dark:text-white mb-6">Attenzione</p>
                <button onclick="document.getElementById('message-modal').classList.add('hidden')" class="w-full bg-gray-900 dark:bg-gray-700 
                hover:bg-black dark:hover:bg-gray-600 text-white font-bold py-3 rounded-xl transition">Chiudi</button>
            </div>
        </div>
    </div>

    <script>
        const QUARTER_DURATIONS_MS = { 'Q1': 600000, 'Q2': 600000, 'Q3': 600000, 'Q4': 600000, 'OT': 300000, '2OT': 300000 };
        const QUARTER_ORDER = ['Q1', 'Q2', 'Q3', 'Q4', 'OT', '2OT'];
        const NEXT_QUARTER = { 'Q1': 'Q2', 'Q2': 'Q3', 'Q3': 'Q4', 'Q4': 'OT', 'OT': '2OT' };
        const DEFAULT_QUARTER = 'Q1';
        
        const COLD_STATUS_THRESHOLD_MS = 720000; // 12 minuti di riposo totale

        const STORAGE_KEY = 'basket_rotation_local_v10'; // Versione aggiornata
        const PMI_ACCUMULATION_RATE_PER_MINUTE = 1.2;
        const PMI_DECAY_RATE_PER_MS = 0.000015;
        
        let gameState = { players: [], isRunning: false, lastUpdateTime: 0, currentQuarter: DEFAULT_QUARTER, quarterTimes: {} };
        let timerInterval = null;
        let selectedPlayerId = null;

        let wallClockInterval = null;
        let lastPMIUpdateTime = Date.now(); 

        // --- HELPER FUNCTIONS ---

        function getRemainingTime() {
            return gameState.quarterTimes[gameState.currentQuarter] || 0;
        }

        function setRemainingTime(ms) {
            gameState.quarterTimes[gameState.currentQuarter] = Math.max(0, ms);
        }

        function getQuarterDuration(q = gameState.currentQuarter) {
            return QUARTER_DURATIONS_MS[q] || 0;
        }

        /** Formatta il tempo da millisecondi a mm:ss. */
        function formatTime(ms) { 
            const totalSeconds = Math.floor(Math.max(0,ms)/1000);
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2,'0');
            const seconds = (totalSeconds % 60).toString().padStart(2,'0');
            return `${minutes}:${seconds}`; 
        }

        function showMessage(t) { document.getElementById('modal-text').textContent = t;
            document.getElementById('message-modal').classList.remove('hidden'); }
        
        function getPerf(player, quarter) {
            let perf = player.performance.find(p => p.quarter === quarter);
            if (!perf) {
                perf = { quarter: quarter, rotations: [] };
                player.performance.push(perf);
            }
            return perf;
        }

        function calcCurrentStintWallClock(player) {
            if (player.status !== 'court') return 0;
            const perf = getPerf(player, gameState.currentQuarter);
            const lastRotation = perf.rotations.at(-1);
            if (lastRotation && lastRotation.wallClockStart) {
                return Date.now() - lastRotation.wallClockStart;
            }
            return 0;
        }

        // Calcola tempo di gioco consecutivo (minG)
        function calcGameStats(player) {
            let currentCons = 0;
            if (player.status === 'court') {
                const perf = getPerf(player, gameState.currentQuarter);
                const lastRotation = perf.rotations.at(-1);
                // Il tempo di gioco consecutivo √® il tempo trascorso del quarto - il tempo di inizio stint
                if (lastRotation && lastRotation.end === null) {
                    currentCons = (getQuarterDuration() - getRemainingTime()) - lastRotation.start;
                }
            }
            return {
                currentCons: currentCons, // minG di questo stint (in ms del cronometro)
            };
        }


        // --- WALL CLOCK TRACKER & PMI STATE UPDATE ---

        function startWallClockTracker() {
            if (gameState.players.length > 0 && !wallClockInterval) {
                lastPMIUpdateTime = Date.now();
                wallClockInterval = setInterval(() => {
                    // Controlla se c'√® tempo di gioco rimanente O se ci sono giocatori in panchina (per il riposo)
                    if (getRemainingTime() > 0 || gameState.players.some(p => p.status === 'bench')) { 
                        const now = Date.now();
                        const diffMs = now - lastPMIUpdateTime;
                        lastPMIUpdateTime = now; 
                        
                        updatePMIState(diffMs); 
                        updateUI(); 
                    }
                }, 1000);
            }
        }
        
        function stopWallClockTracker() {
             if (wallClockInterval) {
                clearInterval(wallClockInterval);
                wallClockInterval = null;
            }
        }
        
        function updatePMIState(diffMs) {
            if (diffMs <= 0) return;
            const diffMinutes = diffMs / 60000;

            gameState.players.forEach(p => {
                let pmiDelta = 0;

                if (p.status === 'court') {
                    // --- ACCUMULATION (ON COURT) ---
                    
                    const stats = calcGameStats(p); 
                    const consecutiveMs = stats.currentCons;
                    const totalWallClockMs = calcCurrentStintWallClock(p); 
            
                    let stintDensity = totalWallClockMs > 0 ? (consecutiveMs / totalWallClockMs) : 0;
                    stintDensity = Math.min(1, Math.max(0, stintDensity)); 
                    
                    const minG_minutes = consecutiveMs / 60000;
           
                    // La PMI si accumula solo se il cronometro √® in esecuzione
                    const gameTimeElapsedMs = gameState.isRunning ? (diffMs) : 0; 
                    const gameTimeElapsedMinutes = gameTimeElapsedMs / 60000;
                    
                    const baseRateAdjusted = PMI_ACCUMULATION_RATE_PER_MINUTE * (1 + stintDensity);
                    const fatigueExponent = 0.1 * Math.max(0, minG_minutes - 6);
                    const fatigueFactor = Math.exp(fatigueExponent);
                    
                    pmiDelta = baseRateAdjusted * gameTimeElapsedMinutes * fatigueFactor;
                    
                    p.totalRestWallClockMs = 0; 

                } else {
                    // --- DECAY (ON BENCH) ---
                    
                    // Il riposo si accumula SEMPRE se il giocatore √® in panchina (requisito)
                    p.totalRestWallClockMs += diffMs; 
                    
                    // Decay is applied continuously regardless of game state
                    pmiDelta = -(PMI_DECAY_RATE_PER_MS * diffMs);
                }

                // Apply Delta and enforce limits
                p.pmiScore = Math.max(0, p.pmiScore + pmiDelta);
                p.pmiScore = Math.min(100, p.pmiScore); 
            });
            
            saveGameState();
        }

        // --- INIZIALIZZAZIONE E SALVATAGGIO ---

        window.onload = function() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    gameState = {
                        players: loaded.players || [],
                        isRunning: loaded.isRunning || false, 
                        quarterTimes: loaded.quarterTimes || {}, 
                        lastUpdateTime: 0,
                        currentQuarter: loaded.currentQuarter || DEFAULT_QUARTER
                    };
                    if (Object.keys(gameState.quarterTimes).length === 0) {
                        QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });
                    }
                    
                    gameState.players.forEach(p => {
                        p.pmiScore = p.pmiScore !== undefined ? p.pmiScore : 0; 
                        p.totalRestWallClockMs = p.totalRestWallClockMs !== undefined ? p.totalRestWallClockMs : 0;
                        p.totalGameTimeMs = p.totalGameTimeMs !== undefined ? p.totalGameTimeMs : 0; 
                    });

                    if (gameState.players.length > 0) { 
                        showSetupOrGame(true);
                        updateUI(); 
                        startWallClockTracker(); 
                        if (loaded.isRunning) {
                            // Riavvia il timer (corregge l'UI del pulsante)
                            toggleTimer(true); 
                        }
                    } 
                    else { showSetupOrGame(false);
                    }
                } catch(e) { console.error("Err loading", e); showSetupOrGame(false); }
            } else { showSetupOrGame(false); }
            if(localStorage.getItem('theme')==='dark') toggleTheme(false);
            const savedOpponentName = localStorage.getItem('opponentName');
            if (savedOpponentName) {
                document.getElementById('opponent-name').value = savedOpponentName;
            }
            document.getElementById('opponent-name').addEventListener('input', (e) => {
                localStorage.setItem('opponentName', e.target.value.trim());
            });
        };

        function saveGameState() {
            const dataToSave = { ...gameState, lastUpdateTime: gameState.isRunning ? Date.now() : gameState.lastUpdateTime };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        }

        function showSetupOrGame(exists) {
            document.getElementById('setup-modal').classList.toggle('hidden', exists);
            document.getElementById('game-container').classList.toggle('hidden', !exists);
        }

        function initializeGame() {
            const txt = document.getElementById('player-input').value.trim();
            if (!txt) return showMessage("Inserisci giocatori.");
            const lines = txt.split('\n').filter(l => l.trim());
            gameState.players = lines.map((l, i) => {
                const m = l.match(/^(\d+)[.\s]+\s*(.*)/);
                const numStr = m ? m[1] : (i + 1).toString();
                const name = m ? m[2].trim() : l.trim();
                return { 
                    id: crypto.randomUUID(), 
                    number: numStr, 
                    name: name || `G${numStr}`, 
                    status: i < 5 ? 'court' : 'bench', 
                    performance: [],
                    pmiScore: 0,
                    totalRestWallClockMs: 0,
                    totalGameTimeMs: 0 
                };
            });
            gameState.currentQuarter = DEFAULT_QUARTER; 
            
            gameState.quarterTimes = {};
            QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });

            gameState.isRunning = false; gameState.lastUpdateTime = 0;
            const initialWallClockStart = Date.now();
            gameState.players.filter(p => p.status === 'court').forEach(p => p.performance = [{ 
                quarter: DEFAULT_QUARTER, 
                rotations: [{ 
                    start: 0, 
                    end: null, 
                    wallClockStart: initialWallClockStart,
                    wallClockEnd: null 
                }] 
            }]);
            saveGameState(); showSetupOrGame(true); updateUI(); startWallClockTracker(); 
        }

        // --- TIMER AND QUARTER LOGIC --- 
        function toggleTimer(force = false) { 
            if (getRemainingTime() <= 0 && !force) { 
                showMessage("Fine quarto.");
                gameState.isRunning = false; saveGameState(); updateUI(); return; 
            } 
            
            gameState.isRunning = !gameState.isRunning; 
            const btn = document.getElementById('start-pause-btn');

            if (gameState.isRunning) { 
                gameState.lastUpdateTime = Date.now(); 
                timerInterval = setInterval(updateTimer, 100);
                startWallClockTracker(); 
                // Aggiornamento UI pulsante: Avvia (Verde) -> Pausa (Arancione)
                btn.textContent = 'Pausa';
                btn.classList.replace('bg-green-600', 'bg-orange-500');
                btn.classList.replace('hover:bg-green-700', 'hover:bg-orange-600');
            } else { 
                clearInterval(timerInterval); 
                // Aggiornamento UI pulsante: Pausa (Arancione) -> Avvia (Verde)
                btn.textContent = 'Avvia';
                btn.classList.replace('bg-orange-500', 'bg-green-600');
                btn.classList.replace('hover:bg-orange-600', 'hover:bg-green-700');
            } 
            saveGameState(); updateUI();
        } 
        
        function updateTimer() { 
            if (!gameState.isRunning) return; 
            const now = Date.now(); 
            const diff = now - gameState.lastUpdateTime;
            let newTime = getRemainingTime() - diff; 
            gameState.lastUpdateTime = now; 
            if (newTime <= 0) { 
                setRemainingTime(0);
                handleQuarterEnd(true); 
            } else { 
                setRemainingTime(newTime);
            } 
            updateUI();
        } 
        
        // AGGIORNATO: Correzione del fattore moltiplicativo (era * 1000)
        function updateRotationEndTimes(elapsed, wallClockEnd = null) { 
            gameState.players.filter(p => p.status === 'court').forEach(p => { 
                const perf = getPerf(p, gameState.currentQuarter); 
                if(perf.rotations.length && perf.rotations.at(-1).end === null) { 
                    const lastStintActiveTime = elapsed - perf.rotations.at(-1).start;
                    // Correzione: lastStintActiveTime √® gi√† in millisecondi del cronometro
                    p.totalGameTimeMs += lastStintActiveTime; 
                    
                    perf.rotations.at(-1).end = elapsed; 
                    if(wallClockEnd) perf.rotations.at(-1).wallClockEnd = wallClockEnd; 
                } 
            });
        } 
        
        function handleQuarterEnd(isTimeOut = false) { 
            toggleTimer(); // Mette in pausa e aggiorna il pulsante
            
            const quarterDuration = getQuarterDuration(); 
            const remainingTime = getRemainingTime();
            const elapsed = quarterDuration - remainingTime; 
            const wallClockNow = Date.now(); 
            
            updateRotationEndTimes(elapsed, wallClockNow); 
            
            if(isTimeOut) { setRemainingTime(0); } 
            
            const nextQ = NEXT_QUARTER[gameState.currentQuarter];
            if (nextQ) { 
                if(isTimeOut) { 
                    gameState.currentQuarter = nextQ;
                    gameState.players.filter(p => p.status === 'court').forEach(p => { 
                        let perf = getPerf(p, nextQ); 
                        perf.rotations.push({ start: 0, end: null, wallClockStart: Date.now(), wallClockEnd: null }); 
                    });
                    showMessage(`Fine Quarto! Passaggio a ${nextQ}.`); 
                } else { 
                    showMessage(`Tempo salvato: ${formatTime(remainingTime)}.`);
                } 
            } else { 
                showMessage("Partita Finita!"); 
                stopWallClockTracker(); 
            } 
            saveGameState(); updateUI();
        } 
        
        function adjustTime(ms) { 
            let newTime = getRemainingTime() + ms; 
            const max = getQuarterDuration(); 
            if(newTime > max) newTime = max;
            if(newTime < 0) newTime = 0; 
            setRemainingTime(newTime); 
            if(gameState.isRunning) gameState.lastUpdateTime = Date.now(); 
            updateUI();
        } 
        
        function changeQuarter() {
            if (gameState.isRunning) {
                showMessage("Metti in pausa il cronometro prima di cambiare quarto.");
                return;
            }
            const newQuarter = document.getElementById('quarter-select').value;
            if (newQuarter !== gameState.currentQuarter) {
                const quarterDuration = getQuarterDuration();
                const remainingTime = getRemainingTime();
                const elapsed = quarterDuration - remainingTime;
                const wallClockNow = Date.now();
                updateRotationEndTimes(elapsed, wallClockNow);
                
                gameState.currentQuarter = newQuarter;
                updateUI();
                saveGameState();
            }
        }

        // --- SUBSTITUTION LOGIC (FIXED TIME CALC) ---
        
        function handleAreaClick(area) {
            if (selectedPlayerId) {
                const playerToMove = gameState.players.find(p => p.id === selectedPlayerId);
                const targetStatus = area === 'court' ? 'court' : 'bench';
                
                if (playerToMove && playerToMove.status !== targetStatus) {
                    if (targetStatus === 'court' && gameState.players.filter(p => p.status === 'court').length >= 5) {
                        showMessage("Campo pieno. Sostituisci un giocatore.");
                        selectedPlayerId = null;
                        updateUI();
                        return;
                    }
                    
                    performSubstitution(playerToMove, targetStatus);
                }
                selectedPlayerId = null;
            }
            updateUI();
        }

        function performSubstitution(player, newStatus) {
            const oldStatus = player.status;
            player.status = newStatus;

            const elapsed = getQuarterDuration() - getRemainingTime();
            const wallClockNow = Date.now();
            
            if (newStatus === 'court') {
                // Logica PMI: Ingresso. Nuova rotazione
                let perf = getPerf(player, gameState.currentQuarter);
                perf.rotations.push({ 
                    start: elapsed, 
                    end: null, 
                    wallClockStart: wallClockNow, 
                    wallClockEnd: null 
                });
                player.totalRestWallClockMs = 0; // Azzera il riposo totale all'ingresso
                
            } else { // newStatus === 'bench'
                // Logica PMI: Uscita. Chiude rotazione e aggiorna totalGameTimeMs (minG)
                const perf = getPerf(player, gameState.currentQuarter);
                const lastRotation = perf.rotations.at(-1);
                if (lastRotation && lastRotation.end === null) {
                    const lastStintActiveTime = elapsed - lastRotation.start;
                    // Correzione: lastStintActiveTime √® gi√† in millisecondi del cronometro
                    player.totalGameTimeMs += lastStintActiveTime; 
                    
                    lastRotation.end = elapsed;
                    lastRotation.wallClockEnd = wallClockNow;
                }
            }
            saveGameState();
        }
        
        function handlePlayerClick(playerId) {
             const player = gameState.players.find(p => p.id === playerId);
             
             if (player.status === 'court') {
                 // Logica Sostituzione: Un giocatore in campo viene selezionato per uscire
                 if (selectedPlayerId === playerId) {
                     selectedPlayerId = null; // Deseleziona
                 } else {
                     selectedPlayerId = playerId;
                 }
                 
             } else {
                 // Logica Ingresso: Un giocatore in panchina pu√≤ entrare se c'√® un posto libero o un giocatore selezionato
                 
                 const courtPlayers = gameState.players.filter(p => p.status === 'court');
                 const playerToSubOut = selectedPlayerId ? gameState.players.find(p => p.id === selectedPlayerId) : null;
                 
                 if (playerToSubOut && playerToSubOut.status === 'court') {
                     // Caso 1: Sostituzione 1-a-1 (swap)
                     performSubstitution(playerToSubOut, 'bench');
                     performSubstitution(player, 'court');
                 } else if (courtPlayers.length < 5) {
                     // Caso 2: Ingresso semplice (se ci sono meno di 5 in campo)
                     performSubstitution(player, 'court');
                 } else {
                     // Caso 3: Nessun giocatore selezionato in campo e campo pieno
                     showMessage("Il campo √® pieno. Seleziona un giocatore in campo da sostituire.");
                 }
                 selectedPlayerId = null;
             }
             updateUI();
        }

        // --- RENDERING & UI ---

        function renderPlayerCard(player) {
            const isCourt = player.status === 'court';
            const cardClass = isCourt ? 'on-court' : '';
            let detailsHtml = '';
            
            // LOGICA PMI COLORE BATTERIA (per giocatori in campo)
            let pmiColor = 'bg-green-500'; 
            if (player.pmiScore > 15) pmiColor = 'bg-yellow-500';
            if (player.pmiScore > 35) pmiColor = 'bg-red-500';
            
            let coldStatusClass = '';
            let coldStatusIcon = '';
            
            const totalGameTime = formatTime(player.totalGameTimeMs);

            if (isCourt) {
                // Giocatori in campo
                const stats = calcGameStats(player);
                const consecutiveTime = formatTime(stats.currentCons);
                
                detailsHtml = `
                    <div class="flex flex-col">
                        <span class="text-xs font-semibold uppercase text-gray-400">Minuti Cons.</span>
                        <span class="text-xl font-extrabold text-white">${consecutiveTime}</span>
                    </div>
                    <div class="flex flex-col items-end">
                        <span class="text-xs font-semibold uppercase text-gray-400">PMI Score</span>
                        <span class="text-xl font-extrabold">${player.pmiScore.toFixed(1)}</span>
                    </div>
                    <div class="absolute bottom-0 left-0 right-0 h-1.5 rounded-b-lg overflow-hidden">
                        <div class="h-full ${pmiColor}" style="width: ${Math.min(100, player.pmiScore)}%"></div>
                    </div>
                `;
            } else {
                // Giocatori in panchina
                const restTime = formatTime(player.totalRestWallClockMs);
                
                // LOGICA COLD STATUS
                if (player.totalRestWallClockMs > COLD_STATUS_THRESHOLD_MS) {
                    coldStatusClass = 'cold-status';
                    coldStatusIcon = '<span class="text-2xl ml-2">üßä</span>'; // Icona di ghiaccio
                }

                detailsHtml = `
                    <div class="flex flex-col items-center justify-center h-full">
                        <span class="text-xs font-semibold uppercase text-gray-500 dark:text-gray-400">Riposo Totale</span>
                        <span class="text-2xl font-extrabold text-gray-900 dark:text-white">${restTime}${coldStatusIcon}</span>
                        <span class="text-xs font-semibold uppercase text-gray-500 dark:text-gray-400 mt-2">PMI: ${player.pmiScore.toFixed(1)}</span>
                    </div>
                `;
            }

            // Classe per la selezione
            const selectionClass = player.id === selectedPlayerId ? 'selected-card ring-yellow-400 ring-2' : '';

            return `
                <div id="player-${player.id}" 
                     class="player-card ${cardClass} ${coldStatusClass} ${selectionClass} p-4 flex flex-col justify-between" 
                     onclick="handlePlayerClick('${player.id}')">
                    <div class="flex justify-between items-start">
                        <div class="court-number">${player.number}</div>
                        <div class="flex flex-col items-end">
                            <div class="text-base font-semibold ${isCourt ? 'text-white' : 'text-gray-800 dark:text-gray-200'}">${player.name}</div>
                            <div class="text-xs font-medium text-gray-400">Tot. Gioco: ${totalGameTime}</div>
                        </div>
                    </div>
                    <div class="relative flex justify-between items-center mt-auto ${isCourt ? '' : 'h-24'}">
                        ${detailsHtml}
                    </div>
                </div>
            `;
        }
        
        function updateUI() {
            const quarterTime = getRemainingTime();
            document.getElementById('timer-display').textContent = formatTime(quarterTime);

            document.getElementById('quarter-select').value = gameState.currentQuarter;
            
            // Aggiorna lo stato del pulsante (Correzione Colore Pausa)
            const btn = document.getElementById('start-pause-btn');
            if (gameState.isRunning) {
                btn.textContent = 'Pausa';
                btn.classList.replace('bg-green-600', 'bg-orange-500');
                btn.classList.replace('hover:bg-green-700', 'hover:bg-orange-600');
            } else {
                btn.textContent = 'Avvia';
                btn.classList.replace('bg-orange-500', 'bg-green-600');
                btn.classList.replace('hover:bg-orange-600', 'hover:bg-green-700');
            }


            const playersInCourt = gameState.players.filter(p => p.status === 'court').sort((a, b) => a.number - b.number);
            const playersOnBench = gameState.players.filter(p => p.status === 'bench').sort((a, b) => a.number - b.number);
            
            const courtArea = document.getElementById('court-area');
            const benchArea = document.getElementById('bench-area');

            courtArea.innerHTML = playersInCourt.map(renderPlayerCard).join('');
            benchArea.innerHTML = playersOnBench.map(renderPlayerCard).join('');
            
            // Stats totali (Placeholder)
            const statsArea = document.getElementById('total-stats-area');
            statsArea.innerHTML = `<div class="p-3 text-sm text-gray-500 dark:text-gray-400">TGL (PMI Score) in debug mode.</div>`;

            saveGameState();
        }

        // --- THEME TOGGLE (EXISTING) ---
        function toggleTheme(save = true) {
            const isDark = document.documentElement.classList.toggle('dark');
            const sunIcon = document.getElementById('sun-icon');
            const moonIcon = document.getElementById('moon-icon');
            
            if (isDark) {
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
            
            if (save) {
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
            }
        }
    </script>
</body>
</html>
