<!DOCTYPE html>
<html lang="it" class="dark">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rotazioni Basket</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÄ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { gray: { 900: '#111827', 800: '#1f2937', 700: '#374151' } } } }
        }
    </script>

    <style>
        /* INCLUSIONE DEL FONT DS-Digital - Assicurati che DS-DIGII.TTF sia presente */
        @font-face {
            font-family: 'DS-Digital';
            src: url('DS-DIGII.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior-y: contain; transition: background-color 0.3s, color 0.3s; }
        
        /* COURT STYLES - SCORRIMENTO ATTIVO */
        .court-area {
            background-color: #eebb88;
            background-image: repeating-linear-gradient(0deg, transparent 0px, transparent 58px, rgba(160, 82, 45, 0.15) 59px, rgba(160, 82, 45, 0.15) 60px), repeating-linear-gradient(0deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 30px, transparent 30px, transparent 60px);
            border: 6px solid #ffffff; 
            box-shadow: inset 0 0 60px rgba(0,0,0,0.15); 
            position: relative; 
            overflow-y: auto; 
            min-height: 400px;
        }
        .court-lines::before { content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 4px; background: #ffffff; pointer-events: none; z-index: 1; }
        .court-lines::after { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 120px; height: 120px; border: 4px solid #ffffff; border-radius: 50%; pointer-events: none; z-index: 1; }
        .dark .court-area { background-color: #cfa06b; border-color: #e2e8f0; }
        
        .bench-area {
            background-color: #f8fafc;
            background-image: linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%, #e2e8f0), linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%, #e2e8f0);
            background-size: 20px 20px; border: 2px dashed #94a3b8; min-height: 140px;
        }
        .dark .bench-area {
            background-color: #1e293b;
            background-image: linear-gradient(45deg, #334155 25%, transparent 25%, transparent 75%, #334155 75%, #334155), linear-gradient(45deg, #334155 25%, transparent 25%, transparent 75%, #334155 75%, #334155);
            border-color: #475569;
        }
        
        /* CARD STYLES */
        .player-card {
            touch-action: manipulation; cursor: pointer; background: rgba(255, 255, 255, 0.98); border-radius: 10px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); transition: transform 0.15s ease, box-shadow 0.15s; z-index: 10; position: relative; 
            min-height: 9rem; 
            height: auto;
            select-none: none; user-select: none;
        }
        .player-card.on-court { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.2); color: white; box-shadow: 0 8px 20px -4px rgba(0, 0, 0, 0.4); }
        .dark .player-card:not(.on-court) { background: rgba(30, 41, 59, 0.98); color: #f1f5f9; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .player-card:active { transform: scale(0.96); }
        .selected-card { ring-width: 3px; ring-color: #fbbf24; transform: scale(1.02); box-shadow: 0 0 15px rgba(251, 191, 36, 0.5); border-color: #fbbf24 !important; z-index: 20; }
        .court-number { color: #fbbf24; font-size: 1.6rem; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        
        /* TIMER FONT DIGITALE E COLORE ROSSO FISSO */
        .timer-display { 
            font-family: 'DS-Digital', 'Courier New', monospace; 
            font-weight: 700; 
            font-size: 3rem; 
            line-height: 1; 
            letter-spacing: -2px; 
            color: #ef4444; /* Red-500 (rosso) */
        }

        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 20px; }
        .is-dragging { opacity: 0.5; transform: scale(0.95); }
        .stats-row:nth-child(even) { background-color: rgba(0,0,0,0.03); }
        .dark .stats-row:nth-child(even) { background-color: rgba(255,255,255,0.02); }
    </style>
</head>
<body class="p-2 sm:p-6 bg-gray-100 dark:bg-gray-900 select-none h-screen flex flex-col">

    <div class="max-w-7xl mx-auto w-full flex flex-col h-full safe-area-padding">
        
        <header class="flex justify-between items-center mb-3 py-2 flex-shrink-0 flex-wrap gap-4">
            <div class="flex flex-col sm:flex-row sm:items-center sm:gap-4 flex-1">
                <div><h1 class="text-2xl sm:text-3xl font-extrabold text-gray-800 dark:text-white tracking-tight">üèÄ Rotazioni <span class="text-blue-600">Pro</span></h1></div>

                <div class="mt-2 sm:mt-0 flex items-center">
                    <label for="opponent-name" class="text-sm font-medium text-gray-500 dark:text-gray-400 mr-2 flex-shrink-0">Avversaria:</label>
                    <input type="text" id="opponent-name" placeholder="Nome Squadra Avversaria" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-white font-medium text-sm py-1 px-2 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none w-full max-w-xs">
                </div>
            </div>
            
            <div class="flex items-center space-x-3 order-last">
                <button onclick="exportToCSV()" class="p-2 rounded-full bg-blue-600 dark:bg-blue-700 text-white shadow-sm hover:shadow-md transition active:scale-95 text-xs font-bold uppercase" title="Esporta Statistiche in CSV">
                    CSV
                </button>
                <button id="theme-toggle" onclick="toggleTheme()" class="p-2 rounded-full bg-white dark:bg-gray-800 text-gray-800 dark:text-yellow-400 shadow-sm hover:shadow-md transition">
                    <svg id="sun-icon" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    <svg id="moon-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </button>
            </div>
        </header>
        
        <div id="setup-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-md border border-gray-200 dark:border-gray-700">
                <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Roster Squadra</h2>
                <textarea id="player-input" rows="8" class="w-full p-4 border border-gray-200 rounded-xl bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-lg font-medium focus:ring-2 focus:ring-blue-500 outline-none transition" placeholder="Esempio:
00. Leardini
23 James">00 Leardini
7 Tomassini
11 Denegri
12 Sankare
13 Marini
17 Ogden
18 Pollone
22 Robinson
27 Simioni
29 Camara</textarea>
                <p class="text-gray-500 text-sm mt-2">Inserisci: "Numero. Nome" oppure "Numero Nome".</p>
                <button onclick="initializeGame()" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 rounded-xl shadow-lg transform active:scale-95 transition text-lg">Inizia Partita</button>
            </div>
        </div>

        <div id="game-container" class="flex-1 flex flex-col min-h-0 pb-4 hidden">
            
            <div class="bg-white dark:bg-gray-800 p-3 sm:p-4 rounded-2xl shadow-sm mb-4 flex flex-wrap sm:flex-nowrap justify-between items-center gap-4 border border-gray-200 dark:border-gray-700 flex-shrink-0">
                <div class="flex-1 text-center sm:text-left order-1 sm:order-2 flex justify-center items-center gap-3">
                    <button onclick="adjustTime(30000)" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-white font-bold shadow-sm transition active:scale-95 flex items-center justify-center text-xs">+30"</button>
                    <div class="bg-gray-100 dark:bg-gray-900 px-6 py-2 rounded-xl border border-gray-200 dark:border-gray-700 inline-block min-w-[200px]">
                        <span id="timer-display" class="timer-display tabular-nums">10:00</span>
                    </div>
                    <button onclick="adjustTime(-30000)" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-white font-bold shadow-sm transition active:scale-95 flex items-center justify-center text-xs">-30"</button>
                </div>

                <div class="w-full sm:w-auto order-2 sm:order-3">
                    <select id="quarter-select" onchange="changeQuarter()" class="w-full sm:w-auto bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 text-gray-800 dark:text-white font-bold text-lg py-3 px-4 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer">
                        <option value="Q1">Q1</option>
                        <option value="Q2">Q2</option>
                        <option value="Q3">Q3</option>
                        <option value="Q4">Q4</option>
                        <option value="OT">OT</option>
                    </select>
                </div>
                
                <div class="flex gap-2 w-full sm:w-auto order-3 sm:order-1 justify-center">
                    <button id="start-pause-btn" onclick="toggleTimer()" class="flex-1 sm:flex-none bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 transition w-28">Avvia</button>
                    <button onclick="showSetupOrGame(false); clearInterval(timerInterval); gameState.isRunning = false;" class="flex-1 sm:flex-none bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 transition w-28">Reset</button>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 flex-1 min-h-0">
                <div class="lg:col-span-3 flex flex-col min-h-0 order-2 lg:order-1">
                    <div class="bg-white dark:bg-gray-800 rounded-t-xl p-3 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center">
                        <h2 class="font-bold text-gray-500 dark:text-gray-400 uppercase text-sm tracking-wider">Panchina</h2>
                        <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-gray-500">Tocca</span>
                    </div>
                    <div id="bench-area" class="bench-area p-3 rounded-b-xl flex-1 overflow-y-auto custom-scroll grid grid-cols-2 lg:grid-cols-1 gap-3 content-start shadow-inner" ondrop="handleDrop(event)" ondragover="allowDrop(event)" onclick="handleAreaClick('bench')"></div>
                </div>
                
                <div class="lg:col-span-9 flex flex-col min-h-0 order-1 lg:order-2 space-y-4">
                    <div class="relative rounded-2xl overflow-hidden shadow-2xl border-[6px] border-white dark:border-gray-500 flex-1 flex flex-col">
                        <div class="absolute top-0 left-0 bg-black/50 text-white px-4 py-1 rounded-br-xl z-20 text-sm font-bold uppercase backdrop-blur-md shadow-sm">In Campo</div>
                        <div class="court-lines absolute inset-0 z-0"></div>
                        <div id="court-area" class="court-area relative z-10 p-4 sm:p-6 flex-1 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4 content-start items-start" ondrop="handleDrop(event)" ondragover="allowDrop(event)" onclick="handleAreaClick('court')"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col h-48 lg:h-64">
                        <div class="p-3 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center"><h2 class="font-bold text-gray-500 dark:text-gray-400 uppercase text-sm tracking-wider">Tabellino</h2></div>
                        <div id="total-stats-area" class="overflow-y-auto custom-scroll p-0 flex-1"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="message-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60] hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-2xl max-w-xs mx-4 text-center">
                <p id="modal-text" class="text-lg font-medium text-gray-800 dark:text-white mb-6">Attenzione</p>
                <button onclick="document.getElementById('message-modal').classList.add('hidden')" class="w-full bg-gray-900 dark:bg-gray-700 hover:bg-black dark:hover:bg-gray-600 text-white font-bold py-3 rounded-xl transition">Chiudi</button>
            </div>
        </div>
    </div>

    <script>
        const QUARTER_DURATIONS_MS = { 'Q1': 600000, 'Q2': 600000, 'Q3': 600000, 'Q4': 600000, 'OT': 300000, '2OT': 300000 };
        const QUARTER_ORDER = ['Q1', 'Q2', 'Q3', 'Q4', 'OT', '2OT'];
        const NEXT_QUARTER = { 'Q1': 'Q2', 'Q2': 'Q3', 'Q3': 'Q4', 'Q4': 'OT', 'OT': '2OT' };
        const DEFAULT_QUARTER = 'Q1';
        
        // CHIAVE DI SALVATAGGIO AGGIORNATA (v9 - Fix PMI/wallClockEnd storage)
        const STORAGE_KEY = 'basket_rotation_local_v9'; 

        // Ristrutturato gameState per gestire i tempi di tutti i quarti
        let gameState = { players: [], isRunning: false, lastUpdateTime: 0, currentQuarter: DEFAULT_QUARTER, quarterTimes: {} };
        let timerInterval = null;
        let selectedPlayerId = null;

        // --- HELPER FUNCTIONS ---

        function getRemainingTime() {
            return gameState.quarterTimes[gameState.currentQuarter] || 0;
        }

        function setRemainingTime(ms) {
            gameState.quarterTimes[gameState.currentQuarter] = Math.max(0, ms);
        }

        function getQuarterDuration(q = gameState.currentQuarter) {
            return QUARTER_DURATIONS_MS[q] || 0;
        }

        function formatTime(ms) { 
            const minutes = Math.floor(Math.max(0,ms)/60000).toString().padStart(2,'0');
            const seconds = Math.floor((Math.max(0,ms)%60000)/1000).toString().padStart(2,'0');
            return `${minutes}:${seconds}`; 
        }
        function showMessage(t) { document.getElementById('modal-text').textContent = t; document.getElementById('message-modal').classList.remove('hidden'); }
        
        // --- INIZIALIZZAZIONE E SALVATAGGIO ---

        window.onload = function() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    gameState = {
                        players: loaded.players || [],
                        isRunning: false, 
                        // Ora carica quarterTimes o lo inizializza
                        quarterTimes: loaded.quarterTimes || {}, 
                        lastUpdateTime: 0,
                        currentQuarter: loaded.currentQuarter || DEFAULT_QUARTER
                    };
                    
                    // Se quarterTimes non √® completo, lo riempiamo con i valori di default
                    if (Object.keys(gameState.quarterTimes).length === 0) {
                        QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });
                    }
                    
                    if (gameState.players.length > 0) { showSetupOrGame(true); updateUI(); } 
                    else { showSetupOrGame(false); }
                } catch(e) { console.error("Err loading", e); showSetupOrGame(false); }
            } else { showSetupOrGame(false); }
            if(localStorage.getItem('theme')==='dark') toggleTheme(false); 
            
            // Inizializza il campo avversario, se salvato in localStorage
            const savedOpponentName = localStorage.getItem('opponentName');
            if (savedOpponentName) {
                document.getElementById('opponent-name').value = savedOpponentName;
            }
            // Aggiungi listener per salvare il nome avversario al cambiamento
            document.getElementById('opponent-name').addEventListener('input', (e) => {
                localStorage.setItem('opponentName', e.target.value.trim());
            });
        };

        function saveGameState() {
            const dataToSave = { ...gameState, lastUpdateTime: gameState.isRunning ? Date.now() : gameState.lastUpdateTime };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        }

        function showSetupOrGame(exists) {
            document.getElementById('setup-modal').classList.toggle('hidden', exists);
            document.getElementById('game-container').classList.toggle('hidden', !exists);
        }

        function initializeGame() {
            const txt = document.getElementById('player-input').value.trim();
            if (!txt) return showMessage("Inserisci giocatori.");
            const lines = txt.split('\n').filter(l => l.trim());
            gameState.players = lines.map((l, i) => {
                const m = l.match(/^(\d+)[.\s]+\s*(.*)/);
                const numStr = m ? m[1] : (i + 1).toString();
                const name = m ? m[2].trim() : l.trim();
                return { id: crypto.randomUUID(), number: numStr, name: name || `G${numStr}`, status: i < 5 ? 'court' : 'bench', performance: [] };
            });
            gameState.currentQuarter = DEFAULT_QUARTER; 
            
            // NUOVA INIZIALIZZAZIONE TEMPI: tutti i quarti partono dalla loro durata massima
            gameState.quarterTimes = {};
            QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });

            gameState.isRunning = false; gameState.lastUpdateTime = 0;
            // Aggiungo wallClockStart alla prima rotazione in campo e wallClockEnd a null
            gameState.players.filter(p => p.status === 'court').forEach(p => p.performance = [{ quarter: DEFAULT_QUARTER, rotations: [{ start: 0, end: null, wallClockStart: Date.now(), wallClockEnd: null }] }]);
            saveGameState(); showSetupOrGame(true); updateUI();
        }

        // --- TIMER AND QUARTER LOGIC ---

        function toggleTimer() {
            if (getRemainingTime() <= 0) { showMessage("Fine quarto."); gameState.isRunning = false; saveGameState(); updateUI(); return; }
            gameState.isRunning = !gameState.isRunning;
            if (gameState.isRunning) { gameState.lastUpdateTime = Date.now(); timerInterval = setInterval(updateTimer, 100); } 
            else { clearInterval(timerInterval); }
            saveGameState(); updateUI();
        }

        function updateTimer() {
            if (!gameState.isRunning) return;
            const now = Date.now(); 
            const diff = now - gameState.lastUpdateTime;
            let newTime = getRemainingTime() - diff; 
            gameState.lastUpdateTime = now;

            if (newTime <= 0) { 
                setRemainingTime(0); 
                handleQuarterEnd(true); // Indica che il quarto √® finito per esaurimento del tempo
            } else {
                setRemainingTime(newTime);
            }
            updateUI();
        }

        function handleQuarterEnd(isTimeOut = false) {
            clearInterval(timerInterval); gameState.isRunning = false;
            
            // 1. Finalizza le rotazioni per il quarto che sta finendo
            const quarterDuration = getQuarterDuration();
            const remaining = getRemainingTime();
            const elapsed = quarterDuration - remaining;
            updateRotationEndTimes(elapsed); // Chiude le rotazioni e salva wallClockEnd

            // 2. Imposta a 0:00 se il quarto √® effettivamente finito
            if(isTimeOut) {
                setRemainingTime(0);
            }

            const nextQ = NEXT_QUARTER[gameState.currentQuarter];
            if (nextQ) {
                // Se si √® arrivati a 0:00, si avanza al quarto successivo
                if(isTimeOut) {
                    gameState.currentQuarter = nextQ; 
                    
                    // Inizia la rotazione per i giocatori in campo nel nuovo quarto (start time √® 0)
                    gameState.players.filter(p => p.status === 'court').forEach(p => {
                        let perf = getPerf(p, nextQ); 
                        // NUOVO: La nuova rotazione inizia a 0 sul Game Clock e Wall Clock a Date.now()
                        perf.rotations.push({ start: 0, end: null, wallClockStart: Date.now(), wallClockEnd: null });
                    });
                    showMessage(`Fine Quarto! Passaggio a ${nextQ}.`);
                } else {
                    // Se non √® finito (e.g. cambio quarto manuale)
                    showMessage(`Tempo salvato: ${formatTime(getRemainingTime())}.`);
                }
            } else { 
                showMessage("Partita Finita!"); 
            }
            saveGameState(); updateUI();
        }

        function adjustTime(ms) {
            let newTime = getRemainingTime() + ms;
            const max = getQuarterDuration();
            if(newTime > max) newTime = max;
            if(newTime < 0) newTime = 0;
            setRemainingTime(newTime);

            if(gameState.isRunning) gameState.lastUpdateTime = Date.now();
            saveGameState(); updateUI();
        }

        function changeQuarter() {
            const newQ = document.getElementById('quarter-select').value;
            if (newQ === gameState.currentQuarter) return;

            // 1. Interrompi il timer e salva il tempo del quarto precedente
            if (gameState.isRunning) { gameState.isRunning = false; clearInterval(timerInterval); }
            
            const oldQ = gameState.currentQuarter;
            const durationOld = getQuarterDuration(oldQ);
            const remainingOld = gameState.quarterTimes[oldQ] || 0;
            const elapsedOld = durationOld - remainingOld;
            
            // 2. Aggiorna i tempi di uscita/entrata nel quarto precedente
            updateRotationEndTimes(elapsedOld); // Chiude le rotazioni e salva wallClockEnd
            
            // 3. Imposta il nuovo quarto
            gameState.currentQuarter = newQ; 
            
            // 4. Aggiorna le rotazioni nel nuovo quarto
            const durationNew = getQuarterDuration(newQ);
            const remainingNew = gameState.quarterTimes[newQ] || durationNew;
            const elapsedNew = durationNew - remainingNew;

            // *** FIX CRITICO: Gestione del Quarto Destinazione ***
            if (remainingNew > 0) {
                // Il quarto non √® finito, apri la rotazione se il giocatore √® in campo.
                gameState.players.filter(p=>p.status==='court').forEach(p => {
                    const perf = getPerf(p, newQ);
                    // Apre una rotazione se non ce n'√® una aperta (end === null)
                    if(!perf.rotations.length || perf.rotations.at(-1).end !== null) {
                        // Aggiungo wallClockStart e wallClockEnd a null
                        perf.rotations.push({start:elapsedNew, end:null, wallClockStart: Date.now(), wallClockEnd: null });
                    }
                });
            } else {
                 // Il quarto √® FINITO (remainingNew === 0). Chiudi forzatamente qualsiasi rotazione aperta
                 gameState.players.forEach(p => { // Controlla TUTTI i giocatori
                    const perf = getPerf(p, newQ);
                    if(perf.rotations.length && perf.rotations.at(-1).end === null) {
                        // Chiudi al tempo massimo trascorso (elapsedNew √® la durata completa, es. 600000ms)
                        perf.rotations.at(-1).end = durationNew; 
                        // Imposta wallClockEnd se non √® gi√† impostato, altrimenti non facciamo nulla.
                        if (!perf.rotations.at(-1).wallClockEnd) perf.rotations.at(-1).wallClockEnd = Date.now(); 
                    }
                 });
            }

            saveGameState(); updateUI();
        }


        // --- STATS AND ROTATION TRACKING ---

        function updateRotationEndTimes(elapsed) {
            gameState.players.filter(p => p.status === 'court').forEach(p => {
                const perf = getPerf(p, gameState.currentQuarter);
                // Chiudi solo se √® effettivamente aperta
                if(perf.rotations.length && perf.rotations.at(-1).end === null) {
                    perf.rotations.at(-1).end = elapsed;
                    // FIX: Salva wallClockEnd quando la rotazione si chiude (uscita dal campo o fine quarto)
                    perf.rotations.at(-1).wallClockEnd = Date.now(); 
                }
            });
        }

        function getPerf(p, q) {
            let perf = p.performance.find(x => x.quarter === q);
            if (!perf) { perf = { quarter: q, rotations: [] }; p.performance.push(perf); }
            return perf;
        }

        function handleSubstitution(p, oldS, newS) {
            // *** MANTENUTO: Blocca qualsiasi modifica alle rotazioni se il quarto √® finito. ***
            if (getRemainingTime() <= 0) {
                // Il cambio √® solo visivo, le statistiche del quarto finito sono invariate.
                return;
            }

            const elapsed = getQuarterDuration() - getRemainingTime();
            const perf = getPerf(p, gameState.currentQuarter);
            if (oldS === 'court') { 
                // USCITA
                if(perf.rotations.length && perf.rotations.at(-1).end === null) {
                    perf.rotations.at(-1).end = elapsed; 
                    // FIX: Salva wallClockEnd al momento dell'uscita
                    perf.rotations.at(-1).wallClockEnd = Date.now();
                }
            } else { 
                // ENTRATA
                if(!perf.rotations.length || perf.rotations.at(-1).end !== null) {
                    // Aggiungo wallClockStart al momento dell'entrata
                    perf.rotations.push({start:elapsed, end:null, wallClockStart: Date.now(), wallClockEnd: null }); // wallClockEnd √® null
                }
            }
        }

        function getQuarterOffset(q) {
            let offset = 0;
            for (let prev of QUARTER_ORDER) { if (prev === q) break; offset += getQuarterDuration(prev); }
            return offset;
        }
        
        function calcQuarterStats(p, qCode) {
            let tot = 0;
            const qDuration = getQuarterDuration(qCode);
            
            // Tempo trascorso nel quarto in questione
            let remaining = gameState.quarterTimes[qCode] || 0;
            let elapsed = qDuration - remaining;

            const perf = p.performance.find(x => x.quarter === qCode);
            if (!perf) return 0;

            perf.rotations.forEach(r => {
                let end = r.end;
                // Se la rotazione √® aperta
                if (end === null) { 
                    // Se √® il quarto corrente E il giocatore √® in campo, usa il tempo trascorso
                    if (qCode === gameState.currentQuarter && p.status === 'court') {
                        end = elapsed; 
                    } else if (remaining === 0) {
                        // Rotazione aperta in un quarto che ha 0:00 
                        end = r.start; 
                    } else {
                        // Rotazione aperta in un quarto non corrente ma non finito (salto manuale)
                        end = elapsed; 
                    }
                }
                if (end !== null && r.start <= end) tot += (end - r.start);
            });
            return tot;
        }

        function calcGameStats(p) {
            let tot = 0, currentCons = 0;
            const currentQDuration = getQuarterDuration();
            const currentQRemaining = getRemainingTime();
            const currentQElapsed = currentQDuration - currentQRemaining;

            p.performance.forEach(perf => {
                const qd = getQuarterDuration(perf.quarter);
                
                const quarterRemaining = gameState.quarterTimes[perf.quarter] || 0;
                const quarterElapsed = qd - quarterRemaining;

                perf.rotations.forEach(r => {
                    const isCurrentActive = (p.status === 'court' && r.end === null && perf.quarter === gameState.currentQuarter);
                    
                    let end;
                    if(isCurrentActive) {
                        end = currentQElapsed;
                    } else if (r.end !== null) {
                        end = r.end;
                    } else {
                        // Rotazione aperta in un quarto non corrente
                        if (perf.quarter !== gameState.currentQuarter && quarterRemaining === 0) {
                            // Rotazione aperta in un quarto passato e FINITO. Preveniamo l'aggiunta di tempo fantasma.
                            end = r.start;
                        } else {
                            // Rotazione aperta in un quarto non corrente ma NON FINITO (e.g. salto manuale)
                            end = quarterElapsed; 
                        }
                    }
                    
                    if(end != null && r.start <= end) tot += (end - r.start);
                });
            });

            // Calcolo del tempo consecutivo (minG per lo stint attuale)
            if(p.status === 'court' && currentQRemaining > 0) {
                const perf = getPerf(p, gameState.currentQuarter);
                if(perf.rotations.length && perf.rotations.at(-1).end === null) currentCons = currentQElapsed - perf.rotations.at(-1).start;
            }
            return { tot, currentCons };
        }
        
        // --- FUNZIONE PER IL PLAYER LOAD / PMI AGGIORNATA ---
        
        /**
         * Calcola il PMI (MetricaFinale) per un singolo stint.
         * Formula: PMI = minG * (1 + stintD) * e^(0.1 * max(0, minG - 6))
         * @param {object} stint - L'oggetto rotazione ({start, end, wallClockStart, wallClockEnd})
         * @param {string} pStatus - Lo status corrente del giocatore ('court' o 'bench')
         * @returns {object} { pmi: number, stintDensity: number }
         */
        function calcPMI(stint, pStatus, isCurrentQuarter) {
            // Se lo stint non ha wallClockStart, salta
            if (!stint.wallClockStart) return { pmi: 0, stintDensity: 0 };
            
            // 1. minG (Game Time, in minuti)
            let gameTimeMs = 0;
            if (stint.end !== null) {
                // Stint chiuso (uso i tempi di gioco registrati)
                gameTimeMs = stint.end - stint.start;
            } else if (pStatus === 'court' && isCurrentQuarter) {
                // Stint aperto (uso i minuti consecutivi attuali)
                const currentQDuration = getQuarterDuration();
                const currentQRemaining = getRemainingTime();
                const currentQElapsed = currentQDuration - currentQRemaining;
                gameTimeMs = currentQElapsed - stint.start;
            } else {
                 // Stint aperto ma non in campo/non nel quarto corrente, ignora per il calcolo PMI
                return { pmi: 0, stintDensity: 0 };
            }
            const minG = Math.max(0, gameTimeMs / 60000); // minG in minuti
            
            // 2. minT (Wall Clock Time, in minuti) - Calcolo
            let wallClockMs = 0;
            let stintD = 0;

            if (stint.end !== null) {
                // Stint chiuso: usa il tempo salvato.
                if (stint.wallClockEnd) {
                    wallClockMs = stint.wallClockEnd - stint.wallClockStart;
                } else {
                    // Fallback per dati precedenti o non salvati: usiamo una densit√† media (0.75) per non rompere TGL.
                    stintD = 0.75; 
                    const stressFactor = Math.exp(0.1 * Math.max(0, minG - 6));
                    const pmi = minG * (1 + stintD) * stressFactor;
                    return { pmi: pmi, stintDensity: stintD };
                }
            } else if (pStatus === 'court' && isCurrentQuarter) {
                // Stint aperto: usa il tempo in real-time
                wallClockMs = Date.now() - stint.wallClockStart;
            } else {
                // Rotazione aperta ma non in campo: calcolo gi√† bloccato sopra.
                return { pmi: 0, stintDensity: 0 };
            }

            // Standard PMI calculation
            const minT = Math.max(0.001, wallClockMs / 60000); // minT in minuti (min 0.001 per evitare divisione per zero)

            // 3. Densit√† (stintD)
            stintD = Math.min(1.0, minG / minT); 

            // 4. Fattore di stress per stint > 6 minuti
            const stressFactor = Math.exp(0.1 * Math.max(0, minG - 6));

            // 5. Metrica Finale (PMI)
            const pmi = minG * (1 + stintD) * stressFactor;
            
            return { pmi, stintDensity: stintD };
        }

        /**
         * Calcola il Total Game Load (TGL) accumulato per il giocatore e le metriche dello stint attivo.
         * @param {object} player - L'oggetto giocatore.
         * @returns {object} { tgl: number, currentStintDensity: number, currentStintWallClockTimeMs: number }
         */
        function calcTotalGameLoad(player) {
            let totalPMI = 0;
            let currentStintDensity = 0;
            let currentStintWallClockTimeMs = 0; // Wall Clock Time (minT) per lo stint attivo
            const currentQ = gameState.currentQuarter;

            player.performance.forEach(perf => {
                const isCurrentQ = perf.quarter === currentQ;
                
                perf.rotations.forEach(r => {
                    const isCurrentStint = r.end === null && player.status === 'court' && isCurrentQ;

                    // Calcola PMI per lo stint
                    const { pmi, stintDensity } = calcPMI(r, player.status, isCurrentQ);
                    
                    totalPMI += pmi;
                    
                    // Se √® lo stint attivo, salva la densit√† e il Wall Clock Time (minT)
                    if (isCurrentStint) {
                        currentStintDensity = stintDensity;
                        currentStintWallClockTimeMs = Date.now() - r.wallClockStart; // minT per lo stint attivo
                    }
                });
            });

            // Arrotonda il TGL all'intero pi√π vicino
            return { tgl: Math.round(totalPMI), currentStintDensity: currentStintDensity, currentStintWallClockTimeMs };
        }
        
        // ----------------------------------------

        function calcRestStats(player) {
            if (player.status === 'court') return 0;
            const currentQ = gameState.currentQuarter;
            const currentElapsed = getQuarterDuration(currentQ) - getRemainingTime();
            const absCurrentTime = getQuarterOffset(currentQ) + currentElapsed;
            let lastExitAbsTime = 0; 
            const playedQuarters = player.performance.map(p => ({ q: p.quarter, idx: QUARTER_ORDER.indexOf(p.quarter), rotations: p.rotations })).sort((a, b) => b.idx - a.idx);
            for (let p of playedQuarters) {
                if (p.idx > QUARTER_ORDER.indexOf(currentQ)) continue;
                if (p.rotations.length > 0) {
                    const lastRot = p.rotations[p.rotations.length - 1];
                    if (lastRot.end !== null) { lastExitAbsTime = getQuarterOffset(p.q) + lastRot.end; break; }
                    // Se la rotazione √® aperta, ma il quarto √® finito (tempo restante 0), consideriamo l'uscita come la fine del quarto.
                    if (gameState.quarterTimes[p.q] === 0) { lastExitAbsTime = getQuarterOffset(p.q) + getQuarterDuration(p.q); break; }
                }
            }
            return Math.max(0, absCurrentTime - lastExitAbsTime);
        }
        
        // --- NUOVA FUNZIONE PER LA GRIGLIA ROTAZIONI (CSV) ---
        
        function getSimplifiedStintGrid(player) {
            const gridData = [];
            let currentOffset = 0;
            
            // Determina il numero massimo di colonne (quarti giocati/definiti)
            let maxQuarterIndex = QUARTER_ORDER.indexOf('Q4');
            if (QUARTER_ORDER.includes(gameState.currentQuarter) && QUARTER_ORDER.indexOf(gameState.currentQuarter) > maxQuarterIndex) {
                maxQuarterIndex = QUARTER_ORDER.indexOf(gameState.currentQuarter);
            }
            
            // Loop su tutti i quarti fino al corrente (o 2OT)
            for (let i = 0; i <= maxQuarterIndex; i++) {
                const qCode = QUARTER_ORDER[i];
                const qDuration = getQuarterDuration(qCode); // Durata del quarto in MS (es. 600000ms)
                
                if (qDuration === 0) continue; // Salta quarti non standardizzati
                
                let quarterRemaining = gameState.quarterTimes[qCode] || qDuration;
                let quarterElapsed = qDuration - quarterRemaining;

                const perf = player.performance.find(x => x.quarter === qCode);
                
                // Variabile che tiene traccia del tempo che √® necessario "saltare" (tempo di riposo)
                let lastEnd = 0; 

                // Aggiungiamo i tempi di riposo/gioco in questo quarto
                if (perf) {
                    // Ordina le rotazioni per tempo di inizio
                    const sortedRotations = [...perf.rotations].sort((a, b) => a.start - b.start);
                    
                    sortedRotations.forEach(r => {
                        let startMs = r.start;
                        let endMs = r.end;
                        
                        // Gestione della rotazione aperta (stint ancora in corso)
                        if (endMs === null) {
                            if (qCode === gameState.currentQuarter && player.status === 'court') {
                                endMs = quarterElapsed;
                            } else if (qCode !== gameState.currentQuarter && quarterRemaining === 0) {
                                // Quarto non corrente ma FINITO (tempo max giocato)
                                endMs = qDuration;
                            } else {
                                // Quarto non corrente ma NON FINITO (tempo trascorso)
                                endMs = quarterElapsed; 
                            }
                        }

                        // 1. Durata del RIposo (Gap) prima dello stint corrente
                        // Se c'√® un gap tra la fine dello stint precedente (lastEnd) e l'inizio di questo (startMs)
                        const restDuration = startMs - lastEnd;
                        if (restDuration > 0) {
                            gridData.push(restDuration / 60000); // Durata riposo in minuti
                            gridData.push(0); // Flag/Durata del GIOCATO (0)
                        } else if (restDuration < 0) {
                             // Caso di sovrapposizione o errore logico, aggiunge un "riposo" di 0
                             gridData.push(0); 
                             gridData.push(0);
                        }

                        // 2. Durata del Gioco (Stint)
                        const playDuration = endMs - startMs;
                        if (playDuration > 0) {
                             gridData.push(0); // Flag/Durata del RIPOSO (0)
                             gridData.push(playDuration / 60000); // Durata gioco in minuti
                        } else {
                            // Stint nullo o punto di errore, aggiunge 0 per entrambi
                            gridData.push(0); 
                            gridData.push(0);
                        }
                        
                        lastEnd = endMs;
                    });
                }
                
                // 3. Durata del RIposo (Gap) dalla fine dell'ultimo stint alla fine del quarto (o al tempo trascorso)
                let quarterEndBoundary = quarterElapsed;
                // Se il quarto √® FINITO, il confine √® la durata intera
                if(quarterRemaining === 0) quarterEndBoundary = qDuration;

                const finalRestDuration = quarterEndBoundary - lastEnd;
                if (finalRestDuration > 0) {
                    gridData.push(finalRestDuration / 60000); // Durata riposo in minuti
                    gridData.push(0); // Flag/Durata del GIOCATO (0)
                }

                // Se il quarto non √® finito, la griglia si ferma qui.
                if (qCode === gameState.currentQuarter && quarterRemaining > 0) {
                    // La griglia si ferma al tempo attuale, gli spazi vuoti non devono essere riempiti.
                } else if (qDuration / 60000 > 0 && finalRestDuration + lastEnd < qDuration) {
                    // Riempimento del resto del quarto se non √® corrente e non √® stato giocato tutto
                    const paddingTime = qDuration - (finalRestDuration + lastEnd);
                    if (paddingTime > 0) {
                        gridData.push(paddingTime / 60000); // Durata riposo in minuti
                        gridData.push(0); // Flag/Durata del GIOCATO (0)
                    }
                }
            }
            
            // La griglia √® [Riposo1, Gioco1, Riposo2, Gioco2, ...] in minuti.
            // I valori di "Gioco" e "Riposo" sono alternati per permettere il grafico a barre sovrapposte.
            // Gioco = linea colorata, Riposo = linea trasparente (usando lo sfondo)
            return gridData.filter((_, index) => index % 2 === 0); // Vogliamo solo i valori di Gioco
        }
        
        function getStintGridHeaders() {
            let headers = [];
            let totalMinutes = 0;
            let maxQuarterIndex = QUARTER_ORDER.indexOf('Q4');
            if (QUARTER_ORDER.includes(gameState.currentQuarter) && QUARTER_ORDER.indexOf(gameState.currentQuarter) > maxQuarterIndex) {
                maxQuarterIndex = QUARTER_ORDER.indexOf(gameState.currentQuarter);
            }
            
            for (let i = 0; i <= maxQuarterIndex; i++) {
                const qCode = QUARTER_ORDER[i];
                const qDurationMinutes = getQuarterDuration(qCode) / 60000;
                
                if (qDurationMinutes > 0) {
                    // Suddividi il quarto in minuti per l'intestazione
                    for(let m = 1; m <= qDurationMinutes; m++) {
                        totalMinutes++;
                        // L'intestazione sar√† 'Q1:M1', 'Q1:M2', ..., 'Q2:M1'
                        headers.push(`${qCode}:${m}`); 
                    }
                }
            }
            
            // Genera le intestazioni per i dati (alternati: Riposo, Gioco)
            const dataHeaders = [];
            headers.forEach(h => {
                dataHeaders.push(`Resto (${h})`); // Colonna per lo sfondo/riposo
                dataHeaders.push(`Gioco (${h})`); // Colonna per la linea colorata
            });
            
            return dataHeaders;
        }

        // --- DRAG/DROP AND UI ---

        function allowDrop(ev) { ev.preventDefault(); }
        function handleDragStart(ev, id) { ev.dataTransfer.setData("pid", id); ev.target.classList.add('is-dragging'); }
        function handleDragEnd(ev) { ev.target.classList.remove('is-dragging'); }
        function handleDrop(ev) {
            ev.preventDefault(); if (ev.target.closest('.player-card')) return; 
            processDrop(ev.dataTransfer.getData("pid"), ev.currentTarget.id === 'court-area' ? 'court' : 'bench');
        }
        function handleDropOnPlayer(ev, tid) { ev.preventDefault(); ev.stopPropagation(); processSwap(ev.dataTransfer.getData("pid"), tid); }
        
        // FUNZIONE PER IL "TOUCH IN/OUT"
        function handlePlayerClick(ev, id) {
            ev.stopPropagation();
            
            // Trova il giocatore per determinare lo status e lo status desiderato
            const p = gameState.players.find(x => x.id === id);
            if (!p) return;

            // TOGGLE SELEZIONE per lo swap
            if (selectedPlayerId === id) { 
                selectedPlayerId = null; 
            } else if (!selectedPlayerId) { 
                selectedPlayerId = id; 
            } else {
                // SECONDO TAP SU ALTRO GIOCATORE: Esegue lo scambio (Swap)
                processSwap(selectedPlayerId, id); 
                selectedPlayerId = null; 
            }

            // Aggiorna l'UI dopo la selezione/deselezione o dopo lo swap
            updateUI(); 
        }
        
        function handleAreaClick(areaType) { 
            if (selectedPlayerId) { 
                processDrop(selectedPlayerId, areaType); 
                selectedPlayerId = null; 
                updateUI(); // Necessario per pulire la selezione e aggiornare lo stato
            } 
        }

        function processDrop(pid, newStatus) {
            const p = gameState.players.find(x => x.id === pid);
            if (!p || p.status === newStatus) return;
            // Solo se il quarto NON √® finito, si applica il limite di 5 in campo
            if (getRemainingTime() > 0 && newStatus === 'court' && gameState.players.filter(x => x.status === 'court').length >= 5) return showMessage("Massimo 5 in campo!");
            
            const oldStatus = p.status;
            p.status = newStatus;
            handleSubstitution(p, oldStatus, newStatus);
            saveGameState(); updateUI();
        }

        function processSwap(id1, id2) {
            const p1 = gameState.players.find(x => x.id === id1);
            const p2 = gameState.players.find(x => x.id === id2);
            if (!p1 || !p2 || p1.id === p2.id) return;
            if (p1.status !== p2.status) {
                const bench = p1.status === 'bench' ? p1 : p2;
                const court = p1.status === 'bench' ? p2 : p1;
                
                // Eseguire lo swap
                bench.status = 'court'; 
                court.status = 'bench';
                
                // Aggiornare le rotazioni
                handleSubstitution(court, 'court', 'bench'); 
                handleSubstitution(bench, 'bench', 'court');
                
                saveGameState(); updateUI();
            } else { showMessage("Scambio valido solo Campo <-> Panchina."); selectedPlayerId = null; updateUI(); }
        }

        globalThis.toggleTheme = (save=true) => {
            const d = document.documentElement.classList.toggle('dark');
            if(save) localStorage.setItem('theme', d?'dark':'light');
            document.getElementById('sun-icon').classList.toggle('hidden', !d);
            document.getElementById('moon-icon').classList.toggle('hidden', d);
        }

        // --- EXPORT CSV AGGIORNATO ---

        function exportToCSV() {
            const data = gameState.players;
            if (data.length === 0) return showMessage("Nessun dato da esportare.");

            const separator = ';'; 
            let csvContent = "\uFEFF"; 
            
            const sortedPlayers = [...data].sort((a, b) => parseInt(a.number) - parseInt(b.number));

            // --- SEZIONE 1: TABELLINO CLASSICO ---
            csvContent += "=== TABELLINO PARTITA ===\r\n";
            
            // 1. Riga Header
            let header = ["Numero", "Nome", "PMI (Carico Totale)", "Q1", "Q2", "Q3", "Q4"]; // AGGIORNATO PMI
            if (QUARTER_ORDER.includes(gameState.currentQuarter) && QUARTER_ORDER.indexOf(gameState.currentQuarter) >= QUARTER_ORDER.indexOf('OT')) {
                header.push("OT/Extra");
            }
            header.push("TOTALE Partita", "Stint Dettagliati (Q:Start-End)", "PMI Dettagliati");
            csvContent += header.join(separator) + "\r\n";

            // 2. Righe Dati
            sortedPlayers.forEach(p => {
                const gameStats = calcGameStats(p); 
                const { tgl } = calcTotalGameLoad(p); // Calcola TGL
                const q1 = formatTime(calcQuarterStats(p, 'Q1'));
                const q2 = formatTime(calcQuarterStats(p, 'Q2'));
                const q3 = formatTime(calcQuarterStats(p, 'Q3'));
                const q4 = formatTime(calcQuarterStats(p, 'Q4'));
                const total = formatTime(gameStats.tot);
                
                // *** AGGIUNTA DETTAGLI STINT E PMI ***
                const detailedStints = getDetailedStints(p); 
                const detailedPMI = getDetailedPMI(p); // NUOVO

                
                // Racchiudo il nome e i dettagli tra virgolette per gestire i separatori
                let row = [p.number, `"${p.name}"`, tgl, q1, q2, q3, q4]; // AGGIUNTO tgl

                if (QUARTER_ORDER.includes(gameState.currentQuarter) && QUARTER_ORDER.indexOf(gameState.currentQuarter) >= QUARTER_ORDER.indexOf('OT')) {
                    const ot = formatTime(calcQuarterStats(p, 'OT') + calcQuarterStats(p, '2OT'));
                    row.push(ot);
                }
                
                row.push(total, `"${detailedStints.replace(/"/g, '""')}"`, `"${detailedPMI.replace(/"/g, '""')}"`); // Sostituisce virgolette interne
                csvContent += row.join(separator) + "\r\n";
            });
            csvContent += "\r\n";

            // --- SEZIONE 2: GRIGLIA DATI PER GRAFICO TIMELINE ---
            csvContent += "=== GRIGLIA ROTAZIONI (minuti) PER GRAFICO TIMELINE ===\r\n";
            csvContent += "I dati sono alternati: 'Riposo (minuti) | Gioco (minuti) | Riposo | Gioco | ...'\r\n";
            
            // Intestazioni per la griglia rotazioni (alternanza Riposo/Gioco per ogni minuto giocato)
            const gridHeaders = ["Numero", "Nome", ...getStintGridHeaders()];
            csvContent += gridHeaders.join(separator) + "\r\n";

            sortedPlayers.forEach(p => {
                // I dati sono in minuti (es. 1.0 = 1 minuto, 0.5 = 30 secondi)
                const gridData = getSimplifiedStintGrid(p); 
                let row = [p.number, `"${p.name}"`, ...gridData];
                csvContent += row.join(separator) + "\r\n";
            });
            csvContent += "\r\n";

            // 3. Trigger Download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                const opponentName = document.getElementById('opponent-name').value.trim() || 'Avversario';
                const currentTime = formatTime(getQuarterDuration() - getRemainingTime()).replace(':', '');
                link.setAttribute("download", `Rotazioni_Timeline_${opponentName}_${gameState.currentQuarter}_${currentTime}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                showMessage("Il tuo browser non supporta il download diretto. Prova su Chrome/Firefox/Safari.");
            }
        }
        
        function getDetailedStints(player) {
            const currentQuarter = gameState.currentQuarter;
            const currentQDuration = getQuarterDuration();
            const currentQRemaining = getRemainingTime();
            const currentQElapsed = currentQDuration - currentQRemaining;

            let details = [];
            const sortedPerformance = player.performance.sort((a, b) => QUARTER_ORDER.indexOf(a.quarter) - QUARTER_ORDER.indexOf(b.quarter));

            sortedPerformance.forEach(perf => {
                const qCode = perf.quarter;
                const qDuration = getQuarterDuration(qCode);
                const quarterRemaining = gameState.quarterTimes[qCode] || 0;
                const quarterElapsed = qDuration - quarterRemaining;

                perf.rotations.forEach(r => {
                    let startMs = r.start;
                    let endMs = r.end;

                    if (endMs === null) {
                        if (qCode === currentQuarter && player.status === 'court') {
                            endMs = currentQElapsed;
                        } else if (quarterRemaining === 0) {
                            endMs = qDuration; 
                            if(endMs === startMs) return; 
                        } else {
                            endMs = quarterElapsed; 
                        }
                    }

                    if (endMs !== null && startMs < endMs) {
                        const startClock = formatTime(qDuration - startMs);
                        const endClock = formatTime(qDuration - endMs);
                        details.push(`${qCode}:${startClock}-${endClock}`);
                    }
                });
            });

            return details.join(' | ');
        }
        
        function getDetailedPMI(player) {
            let details = [];
            const currentQ = gameState.currentQuarter;
            const sortedPerformance = player.performance.sort((a, b) => QUARTER_ORDER.indexOf(a.quarter) - QUARTER_ORDER.indexOf(b.quarter));
            
            sortedPerformance.forEach(perf => {
                const qCode = perf.quarter;
                const isCurrentQ = qCode === currentQ;
                
                perf.rotations.forEach((r, index) => {
                    // Calcolo PMI usa lo stato 'bench' se lo stint √® chiuso, e lo stato reale per lo stint aperto
                    const stintStatus = r.end === null ? player.status : 'bench';
                    const { pmi, stintDensity } = calcPMI(r, stintStatus, isCurrentQ);
                    
                    if (pmi > 0) {
                        const densityP = (stintDensity * 100).toFixed(0);
                        details.push(`${qCode}#${index+1}: ${pmi.toFixed(1)} (D=${densityP}%)`);
                    }
                });
            });

            return details.join(' | ');
        }
        
        // --- UI RENDER ---
        
        function updateUI() {
            if (!gameState.players.length) return;
            const btn = document.getElementById('start-pause-btn');
            btn.textContent = gameState.isRunning ? 'Pausa' : 'Avvia';
            btn.className = gameState.isRunning ? "flex-1 sm:flex-none bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 transition w-28" : "flex-1 sm:flex-none bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 transition w-28";
            
            const td = document.getElementById('timer-display');
            td.textContent = formatTime(getRemainingTime());
            td.className = `timer-display ${getRemainingTime()===0?'text-red-600':''} tabular-nums`;
            document.getElementById('quarter-select').value = gameState.currentQuarter;

            const ca = document.getElementById('court-area'), ba = document.getElementById('bench-area'), sa = document.getElementById('total-stats-area');
            ca.innerHTML=''; ba.innerHTML=''; sa.innerHTML='';

            const sorted = [...gameState.players].sort((a, b) => parseInt(a.number) - parseInt(b.number));

            sorted.forEach(p => {
                const isCourt = p.status === 'court';
                const stats = calcGameStats(p); 
                const restTime = calcRestStats(p);
                // AGGIORNATO: Recupero wallClockTimeMs per lo stint attivo
                const { tgl, currentStintDensity, currentStintWallClockTimeMs } = calcTotalGameLoad(p); 
                
                // La soglia di warning potrebbe essere basata su TGL > 35 (Zona Rossa PDF) O Cons > 5 minuti.
                const warnPMI = tgl > 35;
                const warnCons = stats.currentCons > 300000; 
                const warn = warnPMI || warnCons;
                
                const isSel = selectedPlayerId === p.id;
                
                const selCls = isSel ? 'selected-card' : '';
                const cardBg = isCourt ? 'on-court' : 'bg-white dark:bg-gray-800';
                const border = isCourt ? 'border-0' : 'border border-gray-200 dark:border-gray-600';
                const numClass = isCourt ? 'court-number' : 'text-gray-500 dark:text-gray-400';
                const nameClass = isCourt ? 'court-text-primary' : 'text-gray-800 dark:text-white';
                const statsLabel = isCourt ? 'court-text-secondary' : 'text-gray-400';
                
                // Classi per i nuovi valori: Load in base al warning, Densit√† in base al colore
                const tglValClass = warnPMI ? 'text-red-500 font-bold' : (isCourt ? 'text-green-300' : 'text-green-600 dark:text-green-400');
                const densityValClass = isCourt ? 'text-yellow-400' : 'text-yellow-600 dark:text-yellow-400';
                const consValClass = warnCons ? 'text-red-500 font-bold animate-pulse' : (isCourt ? 'text-white' : 'text-gray-500');

                // CARD HTML: Ristrutturazione per i 3 dati chiave
                const html = `
                <div id="${p.id}" class="player-card flex flex-col justify-between p-3 ${selCls} ${cardBg} ${border} min-h-[9rem] h-auto w-full"
                     draggable="true" ondragstart="handleDragStart(event, '${p.id}')" ondragend="handleDragEnd(event)"
                     ondrop="handleDropOnPlayer(event, '${p.id}')" ondragover="allowDrop(event)"
                     onclick="handlePlayerClick(event, '${p.id}')">
                    <div class="flex justify-between items-start">
                        <span class="jersey-number text-2xl ${numClass}">${p.number}</span>
                        ${isCourt && warn ? '<span class="animate-pulse text-red-500 text-lg">üö®</span>' : ''}
                    </div>
                    <div class="font-bold text-base leading-tight line-clamp-2 break-words ${nameClass}">${p.name}</div>
                    
                    <div class="grid grid-cols-3 gap-2 mt-2 text-xs font-medium">
                        <div class="flex flex-col">
                            <span class="uppercase text-[10px] ${statsLabel}">PMI</span> <span class="font-mono text-sm font-bold ${tglValClass}">${tgl}</span>
                        </div>
                        <div class="flex flex-col">
                            <span class="uppercase text-[10px] ${statsLabel}">${isCourt ? 'Densit√†' : 'Min Tot Gioco'}</span> 
                            <span class="font-mono text-sm ${isCourt ? densityValClass : nameClass}">
                                ${isCourt ? (currentStintDensity * 100).toFixed(0) + '%' : formatTime(stats.tot)} 
                            </span>
                        </div>
                        <div class="flex flex-col items-end">
                            <span class="uppercase text-[10px] ${statsLabel}">${isCourt ? 'Wall Clock (minT)' : 'Riposo'}</span> <span class="font-mono text-sm ${consValClass}">${isCourt ? formatTime(currentStintWallClockTimeMs) : formatTime(restTime)}</span>
                        </div>
                    </div>
                </div>`;
                (isCourt?ca:ba).innerHTML += html;
            });

            // Tabella Statistiche Totali (Header aggiornato)
            let tbl = '<table class="w-full text-sm text-left dark:text-gray-300"><thead class="bg-gray-50 dark:bg-gray-700/50 sticky top-0 z-10 backdrop-blur-sm text-gray-500 dark:text-gray-400 text-xs uppercase tracking-wider"><tr><th class="px-4 py-3 font-medium">#</th><th class="px-4 py-3 font-medium">Nome</th><th class="px-4 py-3 font-medium text-right text-green-600 dark:text-green-400">PMI (Carico Totale)</th><th class="px-4 py-3 font-medium text-right">Q1</th><th class="px-4 py-3 font-medium text-right">Q2</th><th class="px-4 py-3 font-medium text-right">Q3</th><th class="px-4 py-3 font-medium text-right">Q4</th>';
            if (QUARTER_ORDER.includes(gameState.currentQuarter) && QUARTER_ORDER.indexOf(gameState.currentQuarter) >= QUARTER_ORDER.indexOf('OT')) {
                tbl += '<th class="px-4 py-3 font-medium text-right">OT</th>';
            }
            tbl += '<th class="px-4 py-3 font-medium text-right font-bold text-black dark:text-white">Partita</th></tr></thead><tbody>';
            sorted.forEach(p => {
                const gameSt = calcGameStats(p);
                const { tgl } = calcTotalGameLoad(p); // Calcola TGL anche per la tabella
                const warnPMI = tgl > 35;
                const tglClass = warnPMI ? 'text-red-500 font-bold' : 'text-green-600 dark:text-green-400';

                tbl += `<tr class="stats-row border-b border-gray-100 dark:border-gray-700 hover:bg-blue-50 dark:hover:bg-gray-700/50 transition-colors">
                    <td class="px-4 py-2 font-bold text-gray-900 dark:text-white">${p.number}</td>
                    <td class="px-4 py-2 font-medium">${p.name}</td>
                    <td class="px-4 py-2 text-right font-bold ${tglClass}">${tgl}</td> <td class="px-4 py-2 text-right font-mono text-gray-500">${formatTime(calcQuarterStats(p, 'Q1'))}</td>
                    <td class="px-4 py-2 text-right font-mono text-gray-500">${formatTime(calcQuarterStats(p, 'Q2'))}</td>
                    <td class="px-4 py-2 text-right font-mono text-gray-500">${formatTime(calcQuarterStats(p, 'Q3'))}</td>
                    <td class="px-4 py-2 text-right font-mono text-gray-500">${formatTime(calcQuarterStats(p, 'Q4'))}</td>`;
                if (gameState.currentQuarter === 'OT' || gameState.currentQuarter === '2OT') {
                    tbl += `<td class="px-4 py-2 text-right font-mono text-gray-500">${formatTime(calcQuarterStats(p, 'OT') + calcQuarterStats(p, '2OT'))}</td>`;
                }
                tbl += `<td class="px-4 py-2 text-right font-mono text-blue-600 dark:text-blue-400 font-bold">${formatTime(gameSt.tot)}</td></tr>`;
            });
            sa.innerHTML = tbl + '</tbody></table>';
        }
    </script>
</body>
</html>
