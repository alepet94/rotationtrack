<!DOCTYPE html>
<html lang="it" class="dark">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rotazioni Basket PMI Live</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÄ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { gray: { 900: '#111827', 800: '#1f2937', 700: '#374151' } } } }
        }
    </script>

    <style>
        /* INCLUSIONE DEL FONT DS-Digital - Assicurati che DS-DIGII.TTF sia presente */
        @font-face {
            font-family: 'DS-Digital';
            src: url('DS-DIGII.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        body { font-family: 'Roboto', sans-serif; }
        .digital-display { font-family: 'DS-Digital', monospace; }
        .team-container { max-width: 600px; margin: 0 auto; }
        .player-row { cursor: pointer; transition: background-color 0.1s; }
        .player-row:hover { background-color: rgba(255, 255, 255, 0.05); }
    </style>
</head>
<body class="bg-gray-900 text-white dark:bg-gray-900 min-h-screen p-4">

    <div id="substitution-modal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden items-center justify-center">
        <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md">
            <h3 class="text-xl font-bold mb-4">Sostituzione</h3>
            <p id="sub-message" class="mb-4">Seleziona il giocatore che entra al posto di:</p>
            <div id="sub-player-list" class="space-y-2 max-h-60 overflow-y-auto">
                </div>
            <button onclick="closeSubstitutionModal()" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">Annulla</button>
        </div>
    </div>

    <div id="setup-section" class="team-container p-6 bg-gray-800 rounded-lg shadow-xl hidden">
        <h2 class="text-2xl font-bold mb-4">Setup Partita</h2>
        <input type="text" id="opponent-name" placeholder="Nome Avversario" class="w-full p-2 mb-4 bg-gray-700 border border-gray-600 rounded text-white">
        
        <h3 class="text-xl font-semibold mb-2">Aggiungi Giocatore</h3>
        <div class="flex space-x-2 mb-4">
            <input type="number" id="player-number" placeholder="N." class="w-16 p-2 bg-gray-700 border border-gray-600 rounded text-white">
            <input type="text" id="player-name" placeholder="Nome Cognome" class="flex-grow p-2 bg-gray-700 border border-gray-600 rounded text-white">
            <button onclick="addPlayer()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Aggiungi</button>
        </div>
        
        <h3 class="text-xl font-semibold mb-2">Lista Giocatori</h3>
        <div id="setup-player-list" class="bg-gray-700 p-3 rounded max-h-48 overflow-y-auto space-y-1">
            </div>
        
        <button onclick="startGame()" class="mt-6 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 text-lg rounded">Inizia Partita</button>
    </div>

    <div id="game-section" class="team-container hidden">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">VS <span id="display-opponent-name">Avversario</span></h2>
            <button onclick="showSetupOrGame(false)" class="text-sm text-gray-400 hover:text-white">Torna al Setup</button>
        </div>
        
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl mb-4">
            <div class="flex justify-center items-center space-x-4">
                <div class="text-4xl digital-display" id="timer-display">00:00</div>
                <button id="start-pause-btn" onclick="toggleTimer()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Start</button>
            </div>
            <div class="text-center mt-2 text-lg font-semibold" id="quarter-display">Q1</div>
        </div>

        <h3 class="text-xl font-semibold mb-2 text-green-400">In Campo (5)</h3>
        <div id="in-court-list" class="bg-gray-800 p-3 rounded-lg shadow-md space-y-1">
            </div>

        <h3 class="text-xl font-semibold mt-4 mb-2 text-yellow-400">In Panchina</h3>
        <div id="bench-list" class="bg-gray-800 p-3 rounded-lg shadow-md space-y-1">
            </div>

        <div class="mt-6 p-4 bg-gray-800 rounded-lg">
             <h3 class="text-xl font-semibold mb-2">PMI / TGL Totali (Debug)</h3>
             <div id="pmi-debug-list" class="text-sm space-y-1">
                </div>
        </div>
    </div>
    
    <script>
        const DEFAULT_QUARTER_DURATION_MS = 600000; // 10 minuti in ms
        const QUARTER_DURATIONS_MS = { Q1: DEFAULT_QUARTER_DURATION_MS, Q2: DEFAULT_QUARTER_DURATION_MS, Q3: DEFAULT_QUARTER_DURATION_MS, Q4: DEFAULT_QUARTER_DURATION_MS };
        const QUARTER_ORDER = ['Q1', 'Q2', 'Q3', 'Q4'];
        const DEFAULT_QUARTER = 'Q1';

        let gameState = {
            players: [],
            isRunning: false,
            quarterTimes: {},
            lastUpdateTime: 0,
            currentQuarter: DEFAULT_QUARTER,
        };
        let timerInterval = null;
        let playerToSubOut = null; // Giocatore uscente selezionato

        /**
         * LOGICA CRUCIALE PMI
         * ----------------------------------------------------
         */

        /**
         * Calcola il Punteggio PMI (Metrica Finale) per uno stint concluso.
         * La funzione utilizza la formula esponenziale per penalizzare la fatica progressiva.
         * @param {number} activeStintMs - Tempo di gioco effettivo (minG) in ms.
         * @param {number} totalStintMs - Tempo totale trascorso (minT) in ms.
         * @returns {number} Il punteggio PMI per lo stint.
         */
        function calculatePMI(activeStintMs, totalStintMs) {
            const minG = activeStintMs / 60000; // minG in Minuti
            const minT = totalStintMs / 60000; // minT in Minuti

            if (minT === 0 || minG === 0) return 0; // Previene divisioni per zero

            // 1. Componente di Densit√† (stintD)
            const stintD = minG / minT;
            const caricoBase = minG * (1 + stintD);
            
            // 2. Componente di Fatica Esponenziale (penalit√† oltre i 6 minuti)
            // L'esponente si attiva solo se minG > 6
            const exponent = 0.1 * Math.max(0, minG - 6);
            const fattoreFatica = Math.exp(exponent);
            
            // Metrica Finale PMI Stint
            const pmiStintScore = caricoBase * fattoreFatica;

            // Arrotonda a due decimali per chiarezza
            return Math.round(pmiStintScore * 100) / 100; 
        }

        /**
         * Gestisce la fine di uno Stint e accumula il PMI al TGL del giocatore.
         * Chiamata da handleSubstitution().
         * @param {Object} player - Il giocatore che sta uscendo.
         */
        function endStintAndCalculatePMI(player) {
            const now = Date.now();
            
            // Tempo Totale dello Stint (minT)
            const totalStintMs = now - player.stintStartTimestamp; 
            
            // Tempo Attivo dello Stint (minG) √® gi√† accumulato in player.currentStintActiveMs
            const activeStintMs = player.currentStintActiveMs; 

            // Calcolo del PMI Stint
            const pmiStintScore = calculatePMI(activeStintMs, totalStintMs);

            // 1. Aggiorna il TGL (Total Game Load)
            player.pmiScore = Math.round((player.pmiScore + pmiStintScore) * 100) / 100; 

            // 2. Salva lo Stint nella cronologia (per TGL totale e Stint Consistency)
            player.totalStintHistory.push({
                minG: activeStintMs / 60000,
                minT: totalStintMs / 60000,
                pmiScore: pmiStintScore,
                quarter: gameState.currentQuarter,
            });

            // 3. Reset dei dati dello Stint
            player.stintStartTimestamp = null;
            player.currentStintActiveMs = 0;
            player.isCurrentlyPlaying = false;
        }

        /**
         * Funzione per la visualizzazione LIVE della Batteria (PMI stimato)
         * Nota: Questa √® una stima live. Il calcolo finale affidabile avviene in endStintAndCalculatePMI.
         */
        function getLivePMIBattery(player) {
             // Se il giocatore non √® in campo, √® 'ricaricato' (o non ha carico)
            if (!player.isCurrentlyPlaying || player.stintStartTimestamp === null) {
                return { current: 0, percent: 100, color: 'green' };
            }
            
            const now = Date.now();
            const totalStintMs = now - player.stintStartTimestamp;
            const activeStintMs = player.currentStintActiveMs;
            
            const pmiLive = calculatePMI(activeStintMs, totalStintMs);
            
            // Massimale Teorico PMI per la batteria (es. 35, soglia Fascia Rossa TGL)
            const PMI_MAX_BATTERY = 35; 
            
            let percent = 100 - ((pmiLive / PMI_MAX_BATTERY) * 100);
            percent = Math.max(0, percent); // Non pu√≤ andare sotto lo 0%
            
            let color = 'green-500'; // Verde
            if (pmiLive > 15) color = 'yellow-500'; // Gialla
            if (pmiLive > 35) color = 'red-500'; // Rossa

            return { 
                current: pmiLive, 
                percent: Math.round(percent), 
                color: color 
            };
        }


        /**
         * ----------------------------------------------------
         * FUNZIONI CORE DELL'APPLICAZIONE (con modifiche PMI)
         * ----------------------------------------------------
         */

        function saveGameState() {
            localStorage.setItem('rotationsGameState', JSON.stringify(gameState));
        }
        
        // ... (Altre funzioni come addPlayer, initializeUI, ecc.) ...

        function addPlayer() {
            const number = parseInt(document.getElementById('player-number').value);
            const name = document.getElementById('player-name').value.trim();

            if (name && !isNaN(number) && !gameState.players.some(p => p.number === number)) {
                gameState.players.push({
                    number: number,
                    name: name,
                    pmiScore: 0, // TGL iniziale
                    // NUOVI CAMPI PMI
                    stintStartTimestamp: null,
                    currentStintActiveMs: 0, // minG
                    totalStintHistory: [],
                    isCurrentlyPlaying: false,
                });
                document.getElementById('player-name').value = '';
                document.getElementById('player-number').value = '';
                renderSetupPlayers();
                saveGameState();
            } else {
                alert("Inserisci un numero e un nome validi e unici.");
            }
        }
        
        function updateTimer() {
            const now = Date.now();
            const elapsed = now - gameState.lastUpdateTime;

            if (gameState.isRunning) {
                // Sottrai il tempo trascorso
                gameState.quarterTimes[gameState.currentQuarter] -= elapsed;
                
                // Accumula il tempo attivo (minG) per i giocatori in campo
                gameState.players.forEach(p => {
                    if (p.isCurrentlyPlaying) {
                        p.currentStintActiveMs += elapsed;
                    }
                });

                if (gameState.quarterTimes[gameState.currentQuarter] <= 0) {
                    gameState.quarterTimes[gameState.currentQuarter] = 0;
                    toggleTimer(); // Pausa alla fine del quarto
                    alert(`Fine del Quarto ${gameState.currentQuarter}`);
                }
            }
            
            gameState.lastUpdateTime = now;
            updateUI();
        }

        function toggleTimer() {
            gameState.isRunning = !gameState.isRunning;
            const btn = document.getElementById('start-pause-btn');
            
            if (gameState.isRunning) {
                gameState.lastUpdateTime = Date.now();
                timerInterval = setInterval(updateTimer, 100); // Aggiorna ogni 100ms
                btn.textContent = 'Pausa';
                btn.classList.replace('bg-green-600', 'bg-red-600');
                btn.classList.replace('hover:bg-green-700', 'hover:bg-red-700');
            } else {
                clearInterval(timerInterval);
                btn.textContent = 'Start';
                btn.classList.replace('bg-red-600', 'bg-green-600');
                btn.classList.replace('hover:bg-red-700', 'hover:bg-green-700');
            }
            saveGameState();
        }

        function handleSubstitution(playerOut, playerIn = null) {
            // A. Gestione Uscita Giocatore (Out)
            if (playerOut) {
                // 1. Calcola e Accumula PMI Stint
                endStintAndCalculatePMI(playerOut); 
                // Il playerOut ora ha isCurrentlyPlaying=false
            }
            
            // B. Gestione Ingresso Giocatore (In)
            if (playerIn) {
                playerIn.isCurrentlyPlaying = true;
                playerIn.stintStartTimestamp = Date.now();
                playerIn.currentStintActiveMs = 0; // Inizia il nuovo minG
            }

            playerToSubOut = null; // Reset della selezione
            closeSubstitutionModal();
            updateUI();
            saveGameState();
        }


        function openSubstitutionModal(outPlayer) {
            if (outPlayer.isCurrentlyPlaying === false) return; // Non si pu√≤ sostituire chi √® gi√† fuori

            playerToSubOut = outPlayer;
            document.getElementById('sub-message').textContent = `Seleziona il giocatore che entra al posto di: ${outPlayer.name} (#${outPlayer.number})`;
            
            const benchPlayers = gameState.players.filter(p => !p.isCurrentlyPlaying);
            const subList = document.getElementById('sub-player-list');
            subList.innerHTML = '';

            benchPlayers.forEach(p => {
                const button = document.createElement('button');
                button.textContent = `${p.name} (#${p.number})`;
                button.className = 'w-full text-left p-3 bg-gray-700 hover:bg-gray-600 rounded text-white';
                button.onclick = () => handleSubstitution(outPlayer, p);
                subList.appendChild(button);
            });

            document.getElementById('substitution-modal').classList.remove('hidden');
            document.getElementById('substitution-modal').classList.add('flex');
        }

        function closeSubstitutionModal() {
            document.getElementById('substitution-modal').classList.add('hidden');
            document.getElementById('substitution-modal').classList.remove('flex');
            playerToSubOut = null;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function renderPlayerList(listId, players) {
            const list = document.getElementById(listId);
            list.innerHTML = '';
            
            players.forEach(p => {
                const row = document.createElement('div');
                row.className = 'player-row flex justify-between items-center p-2 rounded';
                row.onclick = () => openSubstitutionModal(p); 
                
                // LIVE BATTERY (Visualizzazione Live)
                const battery = getLivePMIBattery(p);
                const batteryBar = `<div class="w-20 bg-gray-600 rounded-full h-2.5">
                                      <div class="h-2.5 rounded-full bg-${battery.color} transition-all duration-300" style="width: ${battery.percent}%;"></div>
                                    </div>`;

                // TEMPO ATTIVO (minG) e TGL (pmiScore)
                const activeTime = p.isCurrentlyPlaying ? formatTime(p.currentStintActiveMs) : '00:00';

                row.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <span class="font-bold w-6 text-center">${p.number}</span>
                        <span>${p.name}</span>
                    </div>
                    <div class="flex items-center space-x-4 text-sm">
                        <span class="text-gray-400">Min. Attivi: ${activeTime}</span>
                        ${p.isCurrentlyPlaying ? batteryBar : ''}
                    </div>
                `;
                list.appendChild(row);
            });
        }
        
        function renderPmiDebug() {
            const list = document.getElementById('pmi-debug-list');
            list.innerHTML = '';
            
            const sortedPlayers = [...gameState.players].sort((a, b) => b.pmiScore - a.pmiScore);

            sortedPlayers.forEach(p => {
                const item = document.createElement('div');
                // Uso del pmiScore come TGL (Total Game Load)
                item.textContent = `${p.name} (#${p.number}): TGL = ${p.pmiScore.toFixed(2)}`;
                list.appendChild(item);
            });
        }

        function updateUI() {
            const quarterTime = gameState.quarterTimes[gameState.currentQuarter] || 0;
            document.getElementById('timer-display').textContent = formatTime(quarterTime);
            document.getElementById('quarter-display').textContent = gameState.currentQuarter;

            const playersInCourt = gameState.players.filter(p => p.isCurrentlyPlaying).sort((a, b) => a.number - b.number);
            const playersOnBench = gameState.players.filter(p => !p.isCurrentlyPlaying).sort((a, b) => a.number - b.number);
            
            renderPlayerList('in-court-list', playersInCourt);
            renderPlayerList('bench-list', playersOnBench);
            renderPmiDebug();
            saveGameState();
        }

        // ... (Altre funzioni come startGame, showSetupOrGame, ecc.) ...

        function startGame() {
            const courtPlayers = gameState.players.filter(p => p.isCurrentlyPlaying);
            if (courtPlayers.length !== 5) {
                alert(`Devi selezionare esattamente 5 giocatori per iniziare. Attualmente in campo: ${courtPlayers.length}`);
                return;
            }

            // Inizializza i timestamp per i 5 in campo
            const now = Date.now();
            courtPlayers.forEach(p => {
                p.stintStartTimestamp = now;
                p.currentStintActiveMs = 0;
            });
            
            document.getElementById('display-opponent-name').textContent = localStorage.getItem('opponentName') || 'Avversario Sconosciuto';
            showSetupOrGame(true);
            updateUI();
        }

        function showSetupOrGame(showGame = false) {
            document.getElementById('setup-section').classList.toggle('hidden', showGame);
            document.getElementById('game-section').classList.toggle('hidden', !showGame);
        }

        function initializeUI() {
            // ... (logica di inizializzazione UI originale) ...
            updateUI();
        }

        // Inizializzazione all'avvio
        window.onload = () => {
            const saved = localStorage.getItem('rotationsGameState');
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    gameState = {
                        players: loaded.players || [],
                        isRunning: loaded.isRunning || false, 
                        quarterTimes: loaded.quarterTimes || {}, 
                        lastUpdateTime: loaded.lastUpdateTime || 0,
                        currentQuarter: loaded.currentQuarter || DEFAULT_QUARTER
                    };
                    if (Object.keys(gameState.quarterTimes).length === 0) {
                        QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });
                    }
                    
                    // NEW: Ensure PMI state is initialized for loaded players
                    gameState.players.forEach(p => {
                        p.pmiScore = p.pmiScore !== undefined ? p.pmiScore : 0;
                        p.stintStartTimestamp = p.stintStartTimestamp !== undefined ? p.stintStartTimestamp : null;
                        p.currentStintActiveMs = p.currentStintActiveMs !== undefined ? p.currentStintActiveMs : 0;
                        p.totalStintHistory = p.totalStintHistory !== undefined ? p.totalStintHistory : [];
                        p.isCurrentlyPlaying = p.isCurrentlyPlaying !== undefined ? p.isCurrentlyPlaying : false;
                    });

                    if(localStorage.getItem('theme')==='dark') toggleTheme(false); 
                    const savedOpponentName = localStorage.getItem('opponentName');
                    if (savedOpponentName) { document.getElementById('opponent-name').value = savedOpponentName; }
                    document.getElementById('opponent-name').addEventListener('input', (e) => {
                        localStorage.setItem('opponentName', e.target.value.trim());
                    });
                    
                    if (gameState.isRunning) {
                         // Ripristina l'intervallo se il gioco era in corso
                        toggleTimer(); 
                    }
                    
                    initializeUI();
                    showSetupOrGame(gameState.players.some(p => p.isCurrentlyPlaying) || loaded.isRunning);

                } catch(e) { console.error("Err loading", e); showSetupOrGame(false); }
            } else { showSetupOrGame(false); }
        };
    </script>
</body>
</html>
