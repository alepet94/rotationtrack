<!DOCTYPE html>
<html lang="it" class="dark">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rotazioni Basket</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÄ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: { extend: { colors: { gray: { 900: '#111827', 800: '#1f2937', 700: '#374151' } } } }
        }
    </script>

    <style>
        /* INCLUSIONE DEL FONT DS-Digital - Assicurati che DS-DIGII.TTF sia presente */
        @font-face {
            font-family: 'DS-Digital';
            src: url('DS-DIGII.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior-y: contain; transition: background-color 0.3s, color 0.3s; }
        
        /* COURT STYLES - SCORRIMENTO ATTIVO */
        .court-area {
            background-color: #eebb88;
            background-image: repeating-linear-gradient(0deg, transparent 0px, transparent 58px, rgba(160, 82, 45, 0.15) 59px, rgba(160, 82, 45, 0.15) 60px), repeating-linear-gradient(0deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 30px, transparent 30px, transparent 60px);
            border: 6px solid #ffffff; 
            box-shadow: inset 0 0 60px rgba(0,0,0,0.15); 
            position: relative; 
            overflow-y: auto; 
            min-height: 400px;
        }
        .court-lines::before { content: ''; position: absolute; top: 50%; left: 0; right: 0;
        height: 4px; background: #ffffff; pointer-events: none; z-index: 1; }
        .court-lines::after { content: '';
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 120px; height: 120px; border: 4px solid #ffffff; border-radius: 50%;
        pointer-events: none; z-index: 1; }
        .dark .court-area { background-color: #cfa06b; border-color: #e2e8f0;
        }
        
        .bench-area {
            background-color: #f8fafc;
            background-image: linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%, #e2e8f0), linear-gradient(45deg, #e2e8f0 25%, transparent 25%, transparent 75%, #e2e8f0 75%, #e2e8f0);
            background-size: 20px 20px; border: 2px dashed #94a3b8; min-height: 140px;
        }
        .dark .bench-area {
            background-color: #1e293b;
            background-image: linear-gradient(45deg, #334155 25%, transparent 25%, transparent 75%, #334155 75%, #334155), linear-gradient(45deg, #334155 25%, transparent 25%, transparent 75%, #334155 75%, #334155);
            border-color: #475569;
        }
        
        /* CARD STYLES */
        .player-card {
            touch-action: manipulation;
            cursor: pointer; background: rgba(255, 255, 255, 0.98); border-radius: 10px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.15s ease, box-shadow 0.15s; z-index: 10; position: relative; 
            min-height: 9rem; 
            height: auto;
            select-none: none; user-select: none;
        }
        .player-card.on-court { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.2); color: white; box-shadow: 0 8px 20px -4px rgba(0, 0, 0, 0.4);
        }
        .dark .player-card:not(.on-court) { background: rgba(30, 41, 59, 0.98); color: #f1f5f9;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .player-card:active { transform: scale(0.96);
        }
        .selected-card { ring-width: 3px; ring-color: #fbbf24; transform: scale(1.02);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.5); border-color: #fbbf24 !important; z-index: 20;
        }
        .court-number { color: #fbbf24; font-size: 1.6rem; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* TIMER FONT DIGITALE E COLORE ROSSO FISSO */
        .timer-display { 
            font-family: 'DS-Digital', 'Courier New', monospace;
            font-weight: 700; 
            font-size: 3rem; 
            line-height: 1; 
            letter-spacing: -2px; 
            color: #ef4444;
            /* Red-500 (rosso) */
        }

        .custom-scroll::-webkit-scrollbar { width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 20px;
        }
        .is-dragging { opacity: 0.5; transform: scale(0.95);
        }
        .stats-row:nth-child(even) { background-color: rgba(0,0,0,0.03);
        }
        .dark .stats-row:nth-child(even) { background-color: rgba(255,255,255,0.02);
        }
    </style>
</head>
<body class="p-2 sm:p-6 bg-gray-100 dark:bg-gray-900 select-none h-screen flex flex-col">

    <div class="max-w-7xl mx-auto w-full flex flex-col h-full safe-area-padding">
        
        <header class="flex justify-between items-center mb-3 py-2 flex-shrink-0 flex-wrap gap-4">
            <div class="flex flex-col sm:flex-row sm:items-center sm:gap-4 flex-1">
                <div><h1 class="text-2xl sm:text-3xl font-extrabold text-gray-800 dark:text-white tracking-tight">üèÄ Rotazioni <span class="text-blue-600">Pro</span></h1></div>

          
                <div class="mt-2 sm:mt-0 flex items-center">
                    <label for="opponent-name" class="text-sm font-medium text-gray-500 dark:text-gray-400 mr-2 flex-shrink-0">Avversaria:</label>
                    <input type="text" id="opponent-name" placeholder="Nome Squadra Avversaria" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-white font-medium text-sm py-1 px-2 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none w-full max-w-xs">
                </div>
     
            </div>
            
            <div class="flex items-center space-x-3 order-last">
                <button onclick="exportToCSV()" class="p-2 rounded-full bg-blue-600 dark:bg-blue-700 text-white shadow-sm hover:shadow-md transition active:scale-95 text-xs font-bold uppercase" title="Esporta Statistiche in CSV">
                    CSV
            
                </button>
                <button id="theme-toggle" onclick="toggleTheme()" class="p-2 rounded-full bg-white dark:bg-gray-800 text-gray-800 dark:text-yellow-400 shadow-sm hover:shadow-md transition">
                    <svg id="sun-icon" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                   
                <svg id="moon-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </button>
            </div>
        </header>
        
        <div id="setup-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 hidden">
          
            <div class="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-md border border-gray-200 dark:border-gray-700">
                <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Roster Squadra</h2>
                <textarea id="player-input" rows="8" class="w-full p-4 border border-gray-200 rounded-xl bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-lg font-medium focus:ring-2 focus:ring-blue-500 outline-none transition" placeholder="Esempio:
00. Leardini
23 James">00 Leardini
7 Tomassini
11 Denegri
12 Sankare
13 Marini
17 Ogden
18 Pollone
22 Robinson
27 Simioni
29 Camara</textarea>
                <p class="text-gray-500 text-sm mt-2">Inserisci: 
"Numero. Nome" oppure "Numero Nome".</p>
                <button onclick="initializeGame()" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 rounded-xl shadow-lg transform active:scale-95 transition text-lg">Inizia Partita</button>
            </div>
        </div>

        <div id="game-container" class="flex-1 flex flex-col min-h-0 pb-4 hidden">
            
            <div class="bg-white dark:bg-gray-800 p-3 sm:p-4 rounded-2xl 
                shadow-sm mb-4 flex flex-wrap sm:flex-nowrap justify-between items-center gap-4 border border-gray-200 dark:border-gray-700 flex-shrink-0">
                <div class="flex-1 text-center sm:text-left order-1 sm:order-2 flex justify-center items-center gap-3">
                    <button onclick="adjustTime(30000)" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-white font-bold shadow-sm transition active:scale-95 flex items-center justify-center text-xs">+30"</button>
                    <div class="bg-gray-100 dark:bg-gray-900 px-6 py-2 rounded-xl 
                        border border-gray-200 dark:border-gray-700 inline-block min-w-[200px]">
                        <span id="timer-display" class="timer-display tabular-nums">10:00</span>
                    </div>
                    <button onclick="adjustTime(-30000)" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-white font-bold shadow-sm transition active:scale-95 flex items-center justify-center text-xs">-30"</button>
           
                </div>

                <div class="w-full sm:w-auto order-2 sm:order-3">
                    <select id="quarter-select" onchange="changeQuarter()" class="w-full sm:w-auto bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 text-gray-800 dark:text-white font-bold text-lg py-3 px-4 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer">
                        <option value="Q1">Q1</option>
          
                        <option value="Q2">Q2</option>
                        <option value="Q3">Q3</option>
                        <option value="Q4">Q4</option>
                        <option value="OT">OT</option>
          
                    </select>
                </div>
                
                <div class="flex gap-2 w-full sm:w-auto order-3 sm:order-1 justify-center">
                    <button id="start-pause-btn" onclick="toggleTimer()" class="flex-1 sm:flex-none bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 
                        transition w-28">Avvia</button>
                    <button onclick="showSetupOrGame(false);
                        clearInterval(timerInterval); gameState.isRunning = false;" class="flex-1 sm:flex-none bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-xl shadow-md active:transform active:scale-95 transition w-28">Reset</button>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 flex-1 min-h-0">
                <div class="lg:col-span-3 flex flex-col min-h-0 order-2 lg:order-1">
   
                    <div class="bg-white dark:bg-gray-800 rounded-t-xl p-3 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center">
                        <h2 class="font-bold text-gray-500 dark:text-gray-400 uppercase text-sm tracking-wider">Panchina</h2>
                        <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-gray-500">Tocca</span>
            
                    </div>
                    <div id="bench-area" class="bench-area p-3 rounded-b-xl flex-1 overflow-y-auto custom-scroll grid grid-cols-2 lg:grid-cols-1 gap-3 content-start shadow-inner" ondrop="handleDrop(event)" ondragover="allowDrop(event)" onclick="handleAreaClick('bench')"></div>
                </div>
                
                <div class="lg:col-span-9 flex flex-col min-h-0 order-1 lg:order-2 space-y-4">
 
                    <div class="relative rounded-2xl overflow-hidden shadow-2xl border-[6px] border-white dark:border-gray-500 flex-1 flex flex-col">
                        <div class="absolute top-0 left-0 bg-black/50 text-white px-4 py-1 rounded-br-xl z-20 text-sm font-bold uppercase backdrop-blur-md shadow-sm">In Campo</div>
                        <div class="court-lines absolute inset-0 z-0"></div>
    
                        <div id="court-area" class="court-area relative z-10 p-4 sm:p-6 flex-1 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3 sm:gap-4 content-start items-start" ondrop="handleDrop(event)" ondragover="allowDrop(event)" onclick="handleAreaClick('court')"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col h-48 lg:h-64">
           
                        <div class="p-3 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center"><h2 class="font-bold text-gray-500 dark:text-gray-400 uppercase text-sm tracking-wider">Tabellino</h2></div>
                        <div id="total-stats-area" class="overflow-y-auto custom-scroll p-0 flex-1"></div>
                    </div>
                </div>
         
            </div>
        </div>
        
        <div id="message-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60] hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-2xl max-w-xs mx-4 text-center">
                <p id="modal-text" class="text-lg font-medium text-gray-800 dark:text-white mb-6">Attenzione</p>
                <button onclick="document.getElementById('message-modal').classList.add('hidden')" class="w-full bg-gray-900 dark:bg-gray-700 
                    hover:bg-black dark:hover:bg-gray-600 text-white font-bold py-3 rounded-xl transition">Chiudi</button>
            </div>
        </div>
    </div>

    <script>
        const QUARTER_DURATIONS_MS = { 'Q1': 600000, 'Q2': 600000, 'Q3': 600000, 'Q4': 600000, 'OT': 300000, '2OT': 300000 };
        const QUARTER_ORDER = ['Q1', 'Q2', 'Q3', 'Q4', 'OT', '2OT'];
        const NEXT_QUARTER = { 'Q1': 'Q2', 'Q2': 'Q3', 'Q3': 'Q4', 'Q4': 'OT', 'OT': '2OT' };
        const DEFAULT_QUARTER = 'Q1';
        
        // Soglia di minuti consecutivi per l'allarme/densit√† ALTA (5 minuti)
        const DENSITY_THRESHOLD_MS = 300000;
        // NEW CONSTANT FOR COLD STATUS (15 minutes in ms)
        const COLD_STATUS_THRESHOLD_MS = 15 * 60 * 1000; // 900000 ms
        // CHIAVE DI SALVATAGGIO MODIFICATA (v8 - PMI Continuo)
        const STORAGE_KEY = 'basket_rotation_local_v8';
        // NEW CONSTANTS FOR PMI LOGIC (Continuous Update)
        // Base PMI increase per minute of pure game time (minG). Used as the coefficient for minG.
        const PMI_ACCUMULATION_RATE_PER_MINUTE = 1.2;
        // Approx 0.9 PMI decay per minute on bench (0.000015 * 60000ms)
        const PMI_DECAY_RATE_PER_MS = 0.000015;
        let gameState = { players: [], isRunning: false, lastUpdateTime: 0, currentQuarter: DEFAULT_QUARTER, quarterTimes: {} };
        let timerInterval = null;
        let selectedPlayerId = null;

        // Wall Clock Interval for continuous Wall Clock/PMI updates
        let wallClockInterval = null;
        let lastPMIUpdateTime = Date.now(); // Per tracciare il tempo tra gli aggiornamenti del PMI

        // --- HELPER FUNCTIONS ---

        function getRemainingTime() {
            return gameState.quarterTimes[gameState.currentQuarter] || 0;
        }

        function setRemainingTime(ms) {
            gameState.quarterTimes[gameState.currentQuarter] = Math.max(0, ms);
        }

        function getQuarterDuration(q = gameState.currentQuarter) {
            return QUARTER_DURATIONS_MS[q] || 0;
        }

        function formatTime(ms) { 
            const minutes = Math.floor(Math.max(0,ms)/60000).toString().padStart(2,'0');
            const seconds = Math.floor((Math.max(0,ms)%60000)/1000).toString().padStart(2,'0');
            return `${minutes}:${seconds}`; 
        }
        function showMessage(t) { document.getElementById('modal-text').textContent = t;
            document.getElementById('message-modal').classList.remove('hidden'); }
        
        function getGameClockTotalElapsed(quarter, remainingTime) {
            const currentQuarterDuration = getQuarterDuration(quarter);
            return currentQuarterDuration - remainingTime;
        }
        
        function getQuarterOffset(quarter) {
            let offset = 0;
            for (const q of QUARTER_ORDER) {
                if (q === quarter) break;
                offset += getQuarterDuration(q);
            }
            return offset;
        }

        // --- WALL CLOCK TRACKER & PMI STATE UPDATE ---

        function startWallClockTracker() {
            // Solo se la partita √® in corso e l'intervallo non √® gi√† attivo
            if (gameState.players.length > 0 && !wallClockInterval) {
                lastPMIUpdateTime = Date.now();
                // Inizializza/reset
                // Aggiorna PMI e UI ogni secondo
                wallClockInterval = setInterval(() => {
                    if (getRemainingTime() > 0 || !gameState.isRunning) { // Check state continuously even if timer stopped
                        const now = Date.now();
     
                        const diffMs = now - lastPMIUpdateTime;
                        lastPMIUpdateTime = now; 
                        
                        // 1. UPDATE PMI STATE (Accumulation/Decay)
                        updatePMIState(diffMs); 

                        // 2. UPDATE UI (Visuals)
                        updateUI(); 
                  
                    }
                }, 1000);
            }
        }
        
        function stopWallClockTracker() {
             if (wallClockInterval) {
                clearInterval(wallClockInterval);
                wallClockInterval = null;
            }
        }
        
        function updatePMIState(diffMs) {
            if (diffMs <= 0) return;
            // Time difference in minutes
            const diffMinutes = diffMs / 60000;
            gameState.players.forEach(p => {
                let pmiDelta = 0;

                if (p.status === 'court') {
                    // --- ACCUMULATION (ON COURT) ---
                    
              
                    // 1. Current Stint Stats (needed for density and consecutive time context)
                    const stats = calcGameStats(p); 
                    const consecutiveMs = stats.currentCons;
                    const totalWallClockMs = calcCurrentStintWallClock(p); 
            
                    let stintDensity = totalWallClockMs > 0 ? (consecutiveMs / totalWallClockMs) : 0;
                    stintDensity = Math.min(1, Math.max(0, stintDensity)); 
                    
                    const minG_minutes = consecutiveMs / 60000;
           
                    
                    // 2. Game Clock (minG) elapsed in the last interval (only if game is running)
                    const gameTimeElapsedMs = gameState.isRunning ? (diffMs) : 0; 
                    const gameTimeElapsedMinutes = gameTimeElapsedMs / 60000;
                    // 3. Calculation of Accumulation Rate
                    
                    // Base Load per Minute (adjusted by density): BaseRate * (1 + Density)
                    const baseRateAdjusted = PMI_ACCUMULATION_RATE_PER_MINUTE * (1 + stintDensity);
                    // Fatigue Factor: e^(0.1 * max(0, minG - 6))
                    const fatigueExponent = 0.1 * Math.max(0, minG_minutes - 6);
                    const fatigueFactor = Math.exp(fatigueExponent);
                    
                    // PMI Delta = Rate * GameTimeElapsed * FatigueFactor
                    pmiDelta = baseRateAdjusted * gameTimeElapsedMinutes * fatigueFactor;
                } else {
                    // --- DECAY (ON BENCH) ---
                    
                    // Decay is applied continuously regardless of game state
                    pmiDelta = -(PMI_DECAY_RATE_PER_MS * diffMs);
                }

                // Apply Delta and enforce minimum of 0 (and max of 100)
                p.pmiScore = Math.max(0, p.pmiScore + pmiDelta);
                p.pmiScore = Math.min(100, p.pmiScore); 
            });
            
            saveGameState();
        }

        // --- INIZIALIZZAZIONE E SALVATAGGIO ---

        window.onload = function() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    gameState = {
                        players: loaded.players || [],
                        isRunning: false, 
                        // Ora carica quarterTimes o lo inizializza
                        quarterTimes: loaded.quarterTimes || {}, 
                        lastUpdateTime: 0,
                        currentQuarter: loaded.currentQuarter || DEFAULT_QUARTER
                    };
                    // Se quarterTimes non √® completo, lo riempiamo con i valori di default
                    if (Object.keys(gameState.quarterTimes).length === 0) {
                        QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });
                    }
                    
                    // NEW: Ensure PMI state is initialized for loaded players
                    gameState.players.forEach(p => {
                        p.pmiScore = p.pmiScore !== undefined ? p.pmiScore : 0; 
                    });

                    // Inizializzazione UI e Wall Clock Tracker
                    if (gameState.players.length > 0) { 
                        showSetupOrGame(true);
                        updateUI(); 
                        startWallClockTracker(); // AVVIA IL TRACKER AL CARICAMENTO
                    } 
                    else { showSetupOrGame(false);
                    }
                } catch(e) { console.error("Err loading", e);
                    showSetupOrGame(false); 
                }
            } else { 
                showSetupOrGame(false);
            }
            if(localStorage.getItem('theme')==='dark') toggleTheme(false);
            // Inizializza il campo avversario, se salvato in localStorage
            const savedOpponentName = localStorage.getItem('opponentName');
            if (savedOpponentName) {
                document.getElementById('opponent-name').value = savedOpponentName;
            }
            // Aggiungi listener per salvare il nome avversario al cambiamento
            document.getElementById('opponent-name').addEventListener('input', (e) => {
                localStorage.setItem('opponentName', e.target.value.trim());
            });
        };

        function saveGameState() {
            const dataToSave = { ...gameState, lastUpdateTime: gameState.isRunning ? Date.now() : gameState.lastUpdateTime };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        }

        function showSetupOrGame(exists) {
            document.getElementById('setup-modal').classList.toggle('hidden', exists);
            document.getElementById('game-container').classList.toggle('hidden', !exists);
        }

        function initializeGame() {
            const txt = document.getElementById('player-input').value.trim();
            if (!txt) return showMessage("Inserisci giocatori.");
            const lines = txt.split('\n').filter(l => l.trim());
            gameState.players = lines.map((l, i) => {
                const m = l.match(/^(\d+)[.\s]+\s*(.*)/);
                const numStr = m ? m[1] : (i + 1).toString();
                const name = m ? m[2].trim() : l.trim();
                return { 
                    id: crypto.randomUUID(), 
                    number: numStr, 
                    name: name || `G${numStr}`, 
                    status: i < 5 ? 'court' : 'bench', 
                    performance: [],
                    // NEW: Continuous PMI State
                    pmiScore: 0
                };
            });
            gameState.currentQuarter = DEFAULT_QUARTER; 
            
            // NUOVA INIZIALIZZAZIONE TEMPI: tutti i quarti partono dalla loro durata massima
            gameState.quarterTimes = {};
            QUARTER_ORDER.forEach(q => { gameState.quarterTimes[q] = QUARTER_DURATIONS_MS[q] || 0; });

            gameState.isRunning = false; gameState.lastUpdateTime = 0;
            // Aggiunta Wall Clock per l'inizializzazione dei giocatori in campo
            const initialWallClockStart = Date.now();
            gameState.players.filter(p => p.status === 'court').forEach(p => p.performance = [{ 
                quarter: DEFAULT_QUARTER, 
                rotations: [{ 
                    start: 0, 
                    end: null, 
                    wallClockStart: initialWallClockStart 
                }] 
            }]);
            
            saveGameState(); 
            showSetupOrGame(true);
            updateUI(); 
            startWallClockTracker(); 
            document.getElementById('quarter-select').value = DEFAULT_QUARTER;
            document.getElementById('opponent-name').value = ''; // Reset opponent name on new game
            localStorage.removeItem('opponentName');
        }

        function toggleTheme(save = true) {
            const isDark = document.documentElement.classList.toggle('dark');
            document.getElementById('sun-icon').classList.toggle('hidden', isDark);
            document.getElementById('moon-icon').classList.toggle('hidden', !isDark);
            if(save) localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }


        // --- TIMER LOGIC ---

        function updateTimer() {
            const now = Date.now();
            if (gameState.lastUpdateTime === 0) {
                gameState.lastUpdateTime = now;
            }
            
            const elapsedMs = now - gameState.lastUpdateTime;
            let remaining = getRemainingTime();
            
            // Non permettere che il tempo vada sotto zero a causa di interruzioni
            if (remaining > 0) {
                remaining = Math.max(0, remaining - elapsedMs);
                setRemainingTime(remaining);

                if (remaining === 0) {
                    toggleTimer(); // Pausa automatica
                    // Auto-advance logic:
                    const currentQIndex = QUARTER_ORDER.indexOf(gameState.currentQuarter);
                    const nextQ = NEXT_QUARTER[gameState.currentQuarter];
                    if (nextQ && gameState.quarterTimes[nextQ] !== 0) {
                        showMessage(`Fine ${gameState.currentQuarter}! Pronti per ${nextQ}.`);
                    } else {
                        showMessage(`Partita terminata!`);
                    }
                }
            }

            // Game Clock Update
            updateGameClockPerformance(elapsedMs); 

            gameState.lastUpdateTime = now;
            
            updateUI();
            saveGameState();
        }

        function toggleTimer() {
            if (!gameState.isRunning) {
                // Avvia o riavvia
                gameState.isRunning = true;
                gameState.lastUpdateTime = Date.now(); 
                timerInterval = setInterval(updateTimer, 100); 
                // Segna l'inizio (o ripresa) Wall Clock per i giocatori in campo
                gameState.players.filter(p => p.status === 'court').forEach(p => {
                    const currentStint = getCurrentStint(p);
                    if (currentStint && !currentStint.wallClockStart) {
                        currentStint.wallClockStart = gameState.lastUpdateTime;
                    }
                });
            } else {
                // Pausa
                clearInterval(timerInterval);
                timerInterval = null;
                gameState.isRunning = false;
                
                // Segna la fine (Pausa) Wall Clock per i giocatori in campo
                const wallClockEnd = Date.now();
                gameState.players.filter(p => p.status === 'court').forEach(p => {
                    const currentStint = getCurrentStint(p);
                    if (currentStint && !currentStint.wallClockEnd) {
                        currentStint.wallClockEnd = wallClockEnd;
                    }
                });
            }
            
            updateUI();
            saveGameState();
            // Il Wall Clock Tracker per il PMI e il Riposo rimane attivo in entrambi i casi.
        }

        function adjustTime(ms) {
            if (gameState.isRunning) return showMessage("Metti in pausa prima di aggiustare il tempo.");
            let newTime = getRemainingTime() + ms;
            if (newTime < 0) newTime = 0;
            if (newTime > getQuarterDuration()) newTime = getQuarterDuration();
            setRemainingTime(newTime);
            updateUI();
            saveGameState();
        }

        function changeQuarter() {
            if (gameState.isRunning) return showMessage("Metti in pausa prima di cambiare quarto.");
            
            const newQuarter = document.getElementById('quarter-select').value;
            if (newQuarter === gameState.currentQuarter) return;

            // Chiudi tutte le rotazioni aperte nel quarto precedente
            gameState.players.filter(p => p.status === 'court').forEach(p => {
                const rotation = getCurrentStint(p);
                if (rotation && rotation.end === null) {
                    rotation.end = getGameClockTotalElapsed(gameState.currentQuarter, getRemainingTime());
                    rotation.wallClockEnd = Date.now();
                }
            });

            gameState.currentQuarter = newQuarter;
            
            // Apri nuove rotazioni per i giocatori in campo nel nuovo quarto
            const newQuarterStartWallClock = Date.now();
            gameState.players.filter(p => p.status === 'court').forEach(p => {
                let quarterPerf = p.performance.find(q => q.quarter === newQuarter);
                if (!quarterPerf) {
                    quarterPerf = { quarter: newQuarter, rotations: [] };
                    p.performance.push(quarterPerf);
                }
                quarterPerf.rotations.push({ 
                    start: 0, 
                    end: null, 
                    wallClockStart: newQuarterStartWallClock
                });
            });

            updateUI();
            saveGameState();
        }
        
        function updateGameClockPerformance(elapsedMs) {
            const elapsed = elapsedMs; // Tempo Game Clock realmente trascorso (solo se isRunning √® true)
            const currentAbsTime = getGameClockTotalElapsed(gameState.currentQuarter, getRemainingTime());

            gameState.players.filter(p => p.status === 'court').forEach(p => {
                const rotation = getCurrentStint(p);
                if (rotation && rotation.end === null) {
                    // La rotazione √® ancora in corso: aggiorna il tempo di fine rotazione (minG/minT)
                    rotation.end = currentAbsTime;
                }
            });
        }
        
        // --- DRAG & DROP / CLICK LOGIC ---

        function handleDragStart(event, playerId) {
            event.dataTransfer.setData("text/plain", playerId);
            event.dataTransfer.effectAllowed = "move";
            document.getElementById(`player-card-${playerId}`).classList.add('is-dragging');
            selectedPlayerId = playerId;
            updateUI();
        }

        function handleDragEnd(event) {
            event.target.classList.remove('is-dragging');
            selectedPlayerId = null;
            updateUI();
        }

        function allowDrop(event) {
            event.preventDefault(); // Necessario per permettere il drop
            event.dataTransfer.dropEffect = "move";
        }

        function handleDrop(event) {
            event.preventDefault();
            const playerId = event.dataTransfer.getData("text/plain");
            const targetAreaId = event.target.closest('#court-area') ? 'court' : (event.target.closest('#bench-area') ? 'bench' : null);
            
            if (targetAreaId) {
                performSubstitution(playerId, targetAreaId);
            }
        }
        
        function handleDropOnPlayer(event, targetPlayerId) {
            event.preventDefault();
            const draggedPlayerId = event.dataTransfer.getData("text/plain");
            
            if (draggedPlayerId === targetPlayerId) return; 

            // Scambio tra due giocatori (bench -> court or court -> bench)
            const draggedPlayer = gameState.players.find(p => p.id === draggedPlayerId);
            const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);

            if (!draggedPlayer || !targetPlayer) return;

            // Se sono nella stessa area, non fare nulla (o gestisci cambio di posizione se necessario)
            if (draggedPlayer.status === targetPlayer.status) {
                // Per ora, un semplice scambio di posizione nell'array, senza effetti sulle stats
                const draggedIndex = gameState.players.indexOf(draggedPlayer);
                const targetIndex = gameState.players.indexOf(targetPlayer);
                
                [gameState.players[draggedIndex], gameState.players[targetIndex]] = [gameState.players[targetIndex], gameState.players[draggedIndex]];
                
                updateUI();
                saveGameState();
                return;
            }

            // Scambio (Sostituzione)
            const targetArea = draggedPlayer.status; // L'area di destinazione per il giocatore droppato √® l'area di partenza del target
            performSubstitution(draggedPlayerId, targetArea);
            performSubstitution(targetPlayerId, draggedPlayer.status);

            // Re-swap statuses to match the actual drag/drop
            draggedPlayer.status = targetPlayer.status;
            targetPlayer.status = targetArea;

            updateUI();
            saveGameState();
        }
        
        function handlePlayerClick(event, playerId) {
            event.stopPropagation();
            
            if (selectedPlayerId === playerId) {
                // Deseleziona se cliccato due volte
                selectedPlayerId = null;
                updateUI();
                return;
            }

            if (selectedPlayerId) {
                // Sostituzione rapida
                const targetArea = gameState.players.find(p => p.id === playerId).status === 'court' ? 'bench' : 'court';
                performSubstitution(selectedPlayerId, targetArea);
                selectedPlayerId = null; 
            } else {
                // Selezione
                selectedPlayerId = playerId;
            }
            updateUI();
        }
        
        function handleAreaClick(targetAreaId) {
            if (selectedPlayerId) {
                performSubstitution(selectedPlayerId, targetAreaId);
                selectedPlayerId = null;
                updateUI();
            }
        }

        function performSubstitution(playerId, targetStatus) {
            const player = gameState.players.find(p => p.id === playerId);
            if (!player || player.status === targetStatus) return;

            const currentAbsTime = getGameClockTotalElapsed(gameState.currentQuarter, getRemainingTime());
            const nowWallClock = Date.now();
            
            if (targetStatus === 'court') {
                // ENTRATA (Bench -> Court)
                player.status = 'court';
                
                // Chiudi l'ultima rotazione in panchina se c'√® stata
                // (Non tracciamo le rotazioni in panchina, ma solo l'ultima uscita dal campo)

                // Apri nuova rotazione in campo
                let quarterPerf = player.performance.find(q => q.quarter === gameState.currentQuarter);
                if (!quarterPerf) {
                    quarterPerf = { quarter: gameState.currentQuarter, rotations: [] };
                    player.performance.push(quarterPerf);
                }
                quarterPerf.rotations.push({ 
                    start: currentAbsTime, 
                    end: null, // Rimane aperta
                    wallClockStart: nowWallClock
                });

            } else {
                // USCITA (Court -> Bench)
                player.status = 'bench';
                
                // Chiudi la rotazione in campo
                const rotation = getCurrentStint(player);
                if (rotation && rotation.end === null) {
                    rotation.end = currentAbsTime;
                    rotation.wallClockEnd = nowWallClock;
                }
            }
            
            // Ordina i giocatori per visualizzazione
            gameState.players.sort((a, b) => {
                if (a.status === 'court' && b.status !== 'court') return -1;
                if (a.status !== 'court' && b.status === 'court') return 1;
                return parseInt(a.number) - parseInt(b.number);
            });

            updateUI();
            saveGameState();
        }
        
        // --- STATS CALCULATION ---

        function getCurrentStint(player) {
            const quarterPerf = player.performance.find(q => q.quarter === gameState.currentQuarter);
            if (!quarterPerf || quarterPerf.rotations.length === 0) return null;
            
            // L'ultima rotazione (stint) √® quella corrente
            return quarterPerf.rotations[quarterPerf.rotations.length - 1];
        }

        function calcQuarterStats(player, quarter) {
            const quarterPerf = player.performance.find(q => q.quarter === quarter);
            if (!quarterPerf) return 0;

            let totalTime = 0;
            const currentAbsTime = getGameClockTotalElapsed(gameState.currentQuarter, getRemainingTime());

            quarterPerf.rotations.forEach(r => {
                let endTime = r.end !== null ? r.end : 0; // Tempo di uscita o 0 se non ancora uscito
                
                if (r.end === null && quarter === gameState.currentQuarter) {
                    // Se la rotazione √® ancora attiva in questo quarto, usa il tempo corrente
                    endTime = currentAbsTime;
                }
                
                if (endTime > r.start) {
                    totalTime += endTime - r.start;
                }
            });

            return totalTime;
        }

        function calcGameStats(player) {
            let totalGameTime = 0;
            let currentConsecutiveTime = 0;
            let totalWallClockTime = 0; // Wall Clock for all stints
            let currentStintWallClockTime = 0; // Wall Clock for current stint

            const currentAbsTime = getGameClockTotalElapsed(gameState.currentQuarter, getRemainingTime());
            const nowWallClock = Date.now();
            
            // Calcolo tempo totale e tempo consecutivo
            for (const q of QUARTER_ORDER) {
                const qPerf = player.performance.find(p => p.quarter === q);
                if (!qPerf) continue;

                qPerf.rotations.forEach(r => {
                    let endTime = r.end !== null ? r.end : 0; 
                    let stintWallClockEnd = r.wallClockEnd !== null ? r.wallClockEnd : 0;
                    
                    if (r.end === null && q === gameState.currentQuarter) {
                        // Rotazione ATTIVA
                        endTime = currentAbsTime;
                        currentConsecutiveTime = endTime - r.start;
                        // Calcola Wall Clock del minT
                        currentStintWallClockTime = r.wallClockStart ? (nowWallClock - r.wallClockStart) : currentConsecutiveTime;
                        stintWallClockEnd = nowWallClock;
                    }
                    
                    if (endTime > r.start) {
                        totalGameTime += endTime - r.start;
                    }
                    if (stintWallClockEnd > r.wallClockStart) {
                        totalWallClockTime += stintWallClockEnd - r.wallClockStart;
                    }
                });
            }

            // Stint Density: minG / minT (current stint)
            let stintDensity = 0;
            if (currentStintWallClockTime > 0) {
                stintDensity = currentConsecutiveTime / currentStintWallClockTime;
            }
            stintDensity = Math.min(1, Math.max(0, stintDensity)); // Clamp between 0 and 1

            return { 
                tot: totalGameTime, 
                currentCons: currentConsecutiveTime, 
                stintDensity: stintDensity,
                totalWallClock: totalWallClockTime,
                currentStintWallClock: currentStintWallClockTime
            };
        }

        function calcCurrentStintWallClock(player) {
            const stint = getCurrentStint(player);
            if (!stint || !stint.wallClockStart) return 0;
            
            // Se la rotazione √® chiusa, usa wallClockEnd
            if (stint.wallClockEnd !== null) {
                return stint.wallClockEnd - stint.wallClockStart;
            }
            
            // Se la rotazione √® aperta, usa il tempo corrente
            return Date.now() - stint.wallClockStart;
        }


        /**
         * FUNZIONE CRITICA - Corretta per evitare errori di runtime
         * Calcola il tempo di Riposo (Wall Clock) per i giocatori in panchina.
         * Se PMI > 0, usa Wall Clock (tempo effettivo di recupero).
         * Se PMI = 0 (recupero completo), usa Game Clock come fallback (vecchia logica).
         */
        function calcRestStats(player) {
            const currentQ = gameState.currentQuarter;
            // Prepara i dati delle performance ordinati dal quarto pi√π recente al pi√π vecchio
            let playedQuarters = [...player.performance].map(p => ({
                q: p.quarter,
                idx: QUARTER_ORDER.indexOf(p.quarter),
                rotations: p.rotations
            })).sort((a, b) => b.idx - a.idx);

            // --- 1. Logica Game Clock (per Fallback) ---
            let lastExitAbsTime = 0;
            const absCurrentTime = getGameClockTotalElapsed(currentQ, getRemainingTime());

            find_game_clock_exit: // Etichetta per uscire dai loop annidati
            for (let p of playedQuarters) {
                if (p.idx > QUARTER_ORDER.indexOf(currentQ)) continue;
                if (p.rotations.length > 0) {
                    const reversedRotations = p.rotations.slice().reverse();
                    for (let rot of reversedRotations) {
                        if (rot.end !== null) { // Trovata un'uscita (Game Clock)
                            lastExitAbsTime = getQuarterOffset(p.q) + rot.end; 
                            break find_game_clock_exit; // Uscita da entrambi i loop
                        } 
                    }
                    // Se il quarto √® finito e l'ultima rotazione √® aperta (end === null)
                    if (p.rotations[p.rotations.length - 1].end === null && gameState.quarterTimes[p.q] === 0) {
                         lastExitAbsTime = getQuarterOffset(p.q) + getQuarterDuration(p.q); 
                         break find_game_clock_exit; // Uscita da entrambi i loop
                    }
                }
            }

            // --- 2. Logica Wall Clock (Prioritaria se PMI > 0) ---
            if(player.pmiScore > 0) { 
                let lastWallClockEnd = 0;
                
                find_wall_clock_end: // Etichetta per uscire dai loop annidati
                for (let p of playedQuarters) { 
                    if (p.idx > QUARTER_ORDER.indexOf(currentQ)) continue;
                    if (p.rotations.length > 0) { 
                        const reversedRotations = p.rotations.slice().reverse();
                        for (let rot of reversedRotations) {
                            if (rot.wallClockEnd) { // Trovata l'ora di uscita (Wall Clock)
                                lastWallClockEnd = rot.wallClockEnd; 
                                break find_wall_clock_end; // Uscita da entrambi i loop
                            } 
                        }
                    } 
                } 
                
                const wallClockRest = Math.max(0, Date.now() - lastWallClockEnd); 
                return wallClockRest;
            } 

            // --- 3. Fallback ---
            // Se PMI = 0, usiamo il Game Clock per il tempo di riposo
            return Math.max(0, absCurrentTime - lastExitAbsTime);
        }

        // --- GRIGLIA ROTAZIONI (CSV) ---
        function getSimplifiedStintGrid(player) { 
            const gridData = [];
            let maxQuarterIndex = QUARTER_ORDER.indexOf('Q4'); // Max Q4
            if (QUARTER_ORDER.indexOf(gameState.currentQuarter) > maxQuarterIndex) {
                maxQuarterIndex = QUARTER_ORDER.indexOf(gameState.currentQuarter);
            }
            
            for (let i = 0; i <= maxQuarterIndex; i++) {
                const q = QUARTER_ORDER[i];
                const qPerf = player.performance.find(p => p.quarter === q);
                const qDuration = getQuarterDuration(q);
                
                if (!qPerf) {
                    gridData.push({ q: q, grid: Array(Math.ceil(qDuration / 300000)).fill(0) }); // 0 per ogni slot di 5 minuti
                    continue;
                }

                const numSlots = Math.ceil(qDuration / 300000); // 5 minuti (300.000 ms)
                const grid = Array(numSlots).fill(0); // 0 = Bench, 1 = Court, 2 = High Density
                const slotDuration = 300000;
                const currentAbsTime = getGameClockTotalElapsed(gameState.currentQuarter, getRemainingTime());

                qPerf.rotations.forEach(r => {
                    let endTime = r.end !== null ? r.end : 0; 
                    
                    if (r.end === null && q === gameState.currentQuarter) {
                        endTime = currentAbsTime;
                    }
                    
                    if (endTime > r.start) {
                        for (let t = r.start; t < endTime; t += 1000) { // Iterazione al secondo
                            const slotIndex = Math.floor(t / slotDuration);
                            if (slotIndex < numSlots) {
                                // Potremmo implementare la logica di densit√† qui in futuro
                                grid[slotIndex] = 1; // Mark as on court
                            }
                        }
                    }
                });

                gridData.push({ q: q, grid: grid });
            }
            return gridData;
        }

        function createStatsTable() {
            // Sort players: Court first, then by number
            const sorted = [...gameState.players].sort((a, b) => {
                if (a.status === 'court' && b.status !== 'court') return -1;
                if (a.status !== 'court' && b.status === 'court') return 1;
                return parseInt(a.number) - parseInt(b.number);
            });

            if (sorted.length === 0) {
                document.getElementById('total-stats-area').innerHTML = `<p class="p-4 text-center text-gray-500">Nessun giocatore inserito nel roster.</p>`;
                return;
            }

            // Determine maximum quarter index to show
            let maxQuarterIndex = QUARTER_ORDER.indexOf('Q4');
            if (QUARTER_ORDER.indexOf(gameState.currentQuarter) > maxQuarterIndex) {
                maxQuarterIndex = QUARTER_ORDER.indexOf(gameState.currentQuarter);
            }

            let tbl = `<table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700 text-sm">
                <thead>
                    <tr class="bg-gray-50 dark:bg-gray-700">
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">#</th>
                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Nome</th>`;
            
            // Add Quarter Headers
            for (let i = 0; i <= maxQuarterIndex; i++) {
                tbl += `<th class="px-4 py-2 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">${QUARTER_ORDER[i]}</th>`;
            }
            
            tbl += `<th class="px-4 py-2 text-right text-xs font-extrabold text-black dark:text-white">Partita</th></tr></thead><tbody>`;

            sorted.forEach(p => {
                const gameSt = calcGameStats(p);
                tbl += `<tr class="stats-row border-b border-gray-100 dark:border-gray-700 hover:bg-blue-50 dark:hover:bg-gray-700/50 transition-colors">
                    <td class="px-4 py-2 font-bold text-gray-900 dark:text-white">${p.number}</td>
                    <td class="px-4 py-2 font-medium">${p.name}</td>`;
                
                // Add Quarter Stats
                let totalMinInQuarters = 0;
                for (let i = 0; i <= maxQuarterIndex; i++) {
                    const qTime = calcQuarterStats(p, QUARTER_ORDER[i]);
                    totalMinInQuarters += qTime;
                    tbl += `<td class="px-4 py-2 text-right font-mono text-gray-500">${formatTime(qTime)}</td>`;
                }
                
                // Total Game Time (Should be equal to totalMinInQuarters, using gameSt.tot for consistency)
                tbl += `<td class="px-4 py-2 text-right font-mono font-extrabold text-gray-900 dark:text-white">${formatTime(gameSt.tot)}</td></tr>`;
                
                // Grid Row
                const gridData = getSimplifiedStintGrid(p);
                tbl += `<tr class="stats-row border-b border-gray-100 dark:border-gray-700/50"><td colspan="2" class="px-4 py-1 text-xs font-semibold text-gray-500 dark:text-gray-400">Rotazioni (MinG / MinT)</td>`;
                
                // Add Grid for Quarters
                let totalColspan = 2; // for Totale col + PMI col
                for (let i = 0; i <= maxQuarterIndex; i++) {
                    const q = QUARTER_ORDER[i];
                    const qDuration = getQuarterDuration(q);
                    const slotDuration = 300000;
                    const numSlots = Math.ceil(qDuration / slotDuration);
                    
                    const quarterGrid = gridData.find(d => d.q === q)?.grid || Array(numSlots).fill(0);
                    
                    let gridHTML = '';
                    quarterGrid.forEach(status => {
                        let color = 'bg-gray-200 dark:bg-gray-700'; // Bench
                        if (status === 1) color = 'bg-blue-500'; // Court
                        // 2 = High Density (non implementato in grid logic qui, ma possibile)
                        gridHTML += `<div class="h-2 w-full ${color} rounded-sm" title="${q}"></div>`;
                    });

                    tbl += `<td class="px-2 py-1" style="max-width: ${numSlots * 15}px;">
                                <div class="flex gap-[2px] h-2">${gridHTML}</div>
                            </td>`;
                    totalColspan++;
                }
                
                // PMI in total column
                const pmiStatusColor = p.pmiScore >= 12 ? 'text-red-500 dark:text-red-400' : (p.pmiScore >= 6 ? 'text-yellow-500 dark:text-yellow-400' : 'text-gray-900 dark:text-white');
                tbl += `<td class="px-4 py-1 text-right font-mono text-lg font-bold ${pmiStatusColor}">${p.pmiScore.toFixed(1)}</td>`;

                tbl += `</tr>`;
            });

            tbl += '</tbody></table>';
            document.getElementById('total-stats-area').innerHTML = tbl;
        }

        // --- EXPORT FUNCTION ---
        function exportToCSV() {
            // Sort players: Court first, then by number
            const sorted = [...gameState.players].sort((a, b) => {
                if (a.status === 'court' && b.status !== 'court') return -1;
                if (a.status !== 'court' && b.status === 'court') return 1;
                return parseInt(a.number) - parseInt(b.number);
            });

            if (sorted.length === 0) {
                return showMessage("Nessun dato da esportare.");
            }

            // Determine maximum quarter index to show
            let maxQuarterIndex = QUARTER_ORDER.indexOf('Q4');
            if (QUARTER_ORDER.indexOf(gameState.currentQuarter) > maxQuarterIndex) {
                maxQuarterIndex = QUARTER_ORDER.indexOf(gameState.currentQuarter);
            }

            const opponentName = document.getElementById('opponent-name').value.trim() || 'Avversaria';
            let csv = `Squadra,,Partita contro,${opponentName}\n`;
            csv += `Data,${new Date().toLocaleDateString()},Quarto Corrente,${gameState.currentQuarter}\n\n`;

            // Headers
            let headers = ['#', 'Nome', 'PMI', 'StintD', 'Totale Partita'];
            for (let i = 0; i <= maxQuarterIndex; i++) {
                headers.push(QUARTER_ORDER[i]);
            }
            csv += headers.join(';') + '\n';

            // Data Rows
            sorted.forEach(p => {
                const gameSt = calcGameStats(p);
                const row = [];
                row.push(p.number);
                row.push(p.name);
                row.push(p.pmiScore.toFixed(1).replace('.', ','));
                row.push((gameSt.stintDensity * 100).toFixed(0) + '%');
                row.push(formatTime(gameSt.tot));
                
                // Quarter Stats
                for (let i = 0; i <= maxQuarterIndex; i++) {
                    row.push(formatTime(calcQuarterStats(p, QUARTER_ORDER[i])));
                }
                
                csv += row.join(';') + '\n';
            });
            
            csv += '\nRotazioni Quarto (5 min slot - 1=Court/0=Bench)\n';
            let gridHeaders = ['#', 'Nome'];
            for (let i = 0; i <= maxQuarterIndex; i++) {
                const q = QUARTER_ORDER[i];
                const qDuration = getQuarterDuration(q);
                const numSlots = Math.ceil(qDuration / 300000);
                for (let j = 1; j <= numSlots; j++) {
                    gridHeaders.push(`${q} Slot ${j}`);
                }
            }
            csv += gridHeaders.join(';') + '\n';

            sorted.forEach(p => {
                const row = [];
                row.push(p.number);
                row.push(p.name);
                const gridData = getSimplifiedStintGrid(p);
                
                for (let i = 0; i <= maxQuarterIndex; i++) {
                    const q = QUARTER_ORDER[i];
                    const qDuration = getQuarterDuration(q);
                    const numSlots = Math.ceil(qDuration / 300000);
                    const quarterGrid = gridData.find(d => d.q === q)?.grid || Array(numSlots).fill(0);
                    
                    // Add grid status
                    row.push(...quarterGrid);
                }
                csv += row.join(';') + '\n';
            });


            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `Report_Rotazioni_${opponentName.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().slice(0, 10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // --- UPDATE UI FUNCTION --- 
        function updateUI() { 
            const courtHTML = []; 
            const benchHTML = [];
            document.getElementById('quarter-select').value = gameState.currentQuarter; 
            document.getElementById('timer-display').textContent = formatTime(getRemainingTime()); 
            document.getElementById('start-pause-btn').textContent = gameState.isRunning ? 'Pausa' : 'Avvia'; 
            document.getElementById('start-pause-btn').classList.toggle('bg-green-600', !gameState.isRunning); 
            document.getElementById('start-pause-btn').classList.toggle('bg-yellow-500', gameState.isRunning);
            
            gameState.players.forEach(p => { 
                const isCourt = p.status === 'court';
                const stats = calcGameStats(p); 
                const totalMs = stats.tot;
                const consecutiveMs = stats.currentCons;
                
                const restTimeMs = calcRestStats(p); // Calcola tempo di riposo in MS
                const restFormatted = formatTime(restTimeMs); 
                
                // NEW: Cold Status Check
                const isCold = !isCourt && restTimeMs > COLD_STATUS_THRESHOLD_MS; 
                
                const pmi = p.pmiScore;
                const pmiThreshold = 12;

                const totalFormatted = formatTime(totalMs);
                const consecutiveFormatted = formatTime(consecutiveMs);
                
                const cardClass = isCourt ? 'on-court' : '';
                const selectedClass = p.id === selectedPlayerId ? 'selected-card ring-4 ring-offset-2 dark:ring-offset-gray-900' : '';
                const density = stats.stintDensity; // Valore 0.0 a 1.0
                const densityColor = density > 0.75 ? 'text-red-500 font-extrabold' : (density > 0.5 ? 'text-yellow-500 font-bold' : 'text-gray-500 dark:text-gray-400');

                const pmiStatusColor = pmi >= pmiThreshold ? 'text-red-500 dark:text-red-400' : (pmi >= 6 ? 'text-yellow-500 dark:text-yellow-400' : (isCourt ? 'text-white' : 'text-gray-900 dark:text-white'));
                const densityFormatted = (density * 100).toFixed(0) + '%';
                
                const playerCardHtml = `
                    <div id="player-card-${p.id}" class="player-card p-3 shadow-lg ${cardClass} ${selectedClass}" draggable="true" ondragstart="handleDragStart(event, '${p.id}')" ondragend="handleDragEnd(event)" ondrop="handleDropOnPlayer(event, '${p.id}')" ondragover="allowDrop(event)" onclick="handlePlayerClick(event, '${p.id}')">
                        ${pmi >= pmiThreshold ? 
                            `<div class="absolute top-0 right-0 p-1 animate-pulse" title="PMI Alto: Rischio Fatica Critica">
                                <svg class="w-6 h-6 text-red-500" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                            </div>` : ''}
                        ${isCold ? 
                            `<div class="absolute top-0 left-0 p-1 text-blue-400 dark:text-blue-300 z-30" title="Cold Status: Riscaldamento Consigliato (> 15 min di riposo)"> 
                                <span class="text-2xl">‚ùÑÔ∏è</span> 
                            </div>` : ''}
                        
                        <div class="flex items-center justify-between mb-2">
                            <span class="court-number font-extrabold">${p.number}</span>
                            <span class="text-sm font-semibold truncate ${isCourt ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'}">${p.name}</span>
                        </div>

                        <div class="flex justify-between items-end border-t border-dashed ${isCourt ? 'border-white/20' : 'border-gray-200 dark:border-gray-700'} pt-2 mt-2">
                            
                            <div class="flex flex-col text-left">
                                <span class="text-xs font-semibold ${isCourt ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'} uppercase">Totale</span>
                                <span class="text-xl font-bold font-mono">${totalFormatted}</span>
                            </div>

                            <div class="flex flex-col text-right">
                                <span class="text-xs font-semibold ${isCourt ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'} uppercase">
                                    ${isCourt ? 'Min. Cons' : 'Riposo'}
                                </span>
                                <span class="text-xl font-bold font-mono">
                                    ${isCourt ? consecutiveFormatted : restFormatted}
                                </span>
                            </div>

                        </div>

                        <div class="flex justify-between items-end mt-2">
                            <div class="flex flex-col text-left">
                                <span class="text-xs font-semibold ${isCourt ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'} uppercase">PMI</span>
                                <span class="text-xl font-bold font-mono ${pmiStatusColor}">${p.pmiScore.toFixed(1)}</span>
                            </div>
                            <div class="flex flex-col text-right">
                                <span class="text-xs font-semibold ${isCourt ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'} uppercase">Stint D.</span>
                                <span class="text-xl font-bold font-mono ${densityColor}">${densityFormatted}</span>
                            </div>
                        </div>

                    </div>
                `;
                
                if (isCourt) {
                    courtHTML.push(playerCardHtml);
                } else {
                    benchHTML.push(playerCardHtml);
                }
            });

            document.getElementById('court-area').innerHTML = courtHTML.join('');
            document.getElementById('bench-area').innerHTML = benchHTML.join('');
            
            createStatsTable();
        }
    </script>
</body>
</html>
